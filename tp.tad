TAD rur ES nat
TAD caracteristica ES string
TAD caracteristicas ES conj(caracteristica)

-- La igualdad de robots es solo por RUR.
TAD Robot
    generos robot
    exporta id, cars, instanciar
    igualdad observacional
        (∀r₁, r₂ : robot) (r₁ =obs r₂ ↔ id(r₁) =obs id(r₂))
    observadores basicos
        id: robot → rur
        cars: robot → caracteristicas
    generadores
        instanciar: rur × caracteristicas → robot
    axiomas
        id(instanciar(r, cs)) ≡ r
        cars(instanciar(r, cs)) ≡ cs
Fin TAD

TAD Restriccion
    generos restriccion
    exporta AND, OR, NOT, VAR, cumple
    igualdad observacional
        (∀ r₁, r₂ : restriccion) (r₁ =obs r₂ ↔
            (∀ c : caracteristicas) (cumple(c, r₁) =obs cumple(c, r₂)))
    observadores basicos
        cumple: caracteristicas × restriccion → bool
    generadores
        AND: restriccion × restriccion → restriccion
        OR: restriccion × restriccion → restriccion
        NOT: restriccion → restriccion
        VAR: caracteristica → restriccion
    axiomas
        cumple(cs, VAR(c)) ≡ c ∈ cs
        cumple(cs, NOT(c)) ≡ ¬(cumple(cs, c))
        cumple(cs, AND(c1, c2)) ≡ cumple(cs, c1) ∧ cumple(cs, c2)
        cumple(cs, OR(c1, c2)) ≡ cumple(cs, c1) ∨ cumple(cs, c2)
Fin TAD

TAD estacion ES string
TAD conexion ES ⟨estacion, restriccion⟩

TAD Mapa
    generos mapa
    igualdad observacional
        (∀ m₁, m₂ : mapa) (m₁ =obs m₂ ↔
            estaciones(m₁) =obs estaciones(m₂) ∧ₗ
            (∀ e ∈ estaciones(m₁)) (conexiones(m₁, e) =obs conexiones(m₂, e)))
    observadores basicos
        estaciones: mapa → conj(estacion)
        conexiones: mapa m × estacion e → conj(conexion) {e ∈ estaciones(m)}
    generadores
        nuevo: → mapa
        crearEst: mapa m × estacion a → mapa {a ∉ estaciones(m)}
        conectar: mapa m × estacion a × estacion b × restriccion → mapa {a, b ∈ estaciones(m)}
    otras operaciones
        esBloqueante: mapa m × caracteristicas × estacion e → bool {e ∈ estaciones(m)}
        conectadas: mapa m × estacion a × estacion b → bool {a, b ∈ estaciones(m)}
        caminos: mapa m × estacion a × estacion b → conj(restriccion) {a, b ∈ estaciones(m) ∧ conectadas(m, a, b)}
    axiomas
        conexiones(crearEst(m, e), k) ≡ ϕ
        conexiones(conectar(m, a, b, r), e) ≡
            if e ≡ a then
                ⟨b, r⟩ ∪ conexiones(m, e)
            else
                if e ≡ b then
                    ⟨a, r⟩ ∪ conexiones(m, e)
                else
                    conexiones(m, e)
                fi
            fi

        estaciones(nuevo) ≡ ϕ
        estaciones(crearEst(m, e)) ≡ { e } ∪ estaciones(m)
        estaciones(conectar(m, a, b)) ≡ estaciones(m)

        -- Se fija si es bloqueante poner al robot en la estacion e
        esBloqueante(m, r, e) ≡
            if ϕ?(conexiones(m, e)) then
                False
            else
                esBloqueante'(conexiones(m, e), r)
            fi

        esBloqueante'(c, r) ≡
            if ϕ?(c) then
                True
            else
                if cumple(r, π₂(dameUno(c))) then
                    False
                else
                    esBloqueante'(sinUno(c), r)
                fi
            fi

        -- Se fija si la estacion b esta en las conexiones inmediatas de a
        conectadas(m, a, b) ≡ conectadas'(b, conexiones(m, a))

        conectadas'(a, c) ≡
            if ϕ?(c) then
                False
            else
                if π₁(dameUno(c)) ≡ a then
                    True
                else
                    conectadas'(a, sinUno(c))
                fi
            fi

        caminos(m, a, b) ≡ caminos'(b, conexiones(m, a))

        caminos'(a, c) ≡
            if ϕ?(c) then
                ϕ
            else
                if π₁(dameUno(c)) ≡ a then
                    π₂(dameUno(c)) ∪ caminos'(a, sinUno(c))
                else
                    caminos'(a, sinUno(c))
                fi
            fi
Fin TAD

-- TODO: preguntar si podemos usar maybe...
-- NOTA: las estaciones podrian no devolver ningun robot, hence Maybe.

TAD Maybe(α)
    generos maybe
    igualdad observacional
        (∀ m₁, m₂ : maybe(α)) (m₁ =obs m₂ ↔
            (isJust(m₁) =obs isJust(m₂) =obs true) ∧ₗ fromJust(m₁) =obs fromJust(m₂))
    observadores basicos
        isJust: maybe(α) → bool
        fromJust: maybe(α) x → α {isJust(x)}
    generadores
        nothing: → maybe(α)
        just: α → maybe(α)
    otras operaciones
        isNothing: maybe(α) → bool
        fromMaybe: maybe(α) × α → α
    axiomas
        isJust(nothing) ≡ false
        isJust(just(x)) ≡ true

        fromJust(just(x)) ≡ x

        fromMaybe(nothing, a) ≡ a
        fromMaybe(just(x), a) ≡ x

        isNothing(x) ≡ ¬isJust(x)
Fin TAD

TAD Ciudad
    generos ciudad
    igualdad observacional
        (∀ c₁, c₂ : ciudad) (c₁ =obs c₂ ↔
            mapeo(c₁) =obs mapeo(c₂) ∧ robots(c₁) =obs robots(c₂) ∧ₗ
            (∀ r ∈ robots(c₁)) (historial(c₁, r) =obs historial(c₂, r)))
    observadores basicos
        mapeo: ciudad → mapa
        robots: ciudad → conj(robot)
        historial: ciudad c × robot r → pila(conexion) {r ∈ robots(c)}
    generadores
        nueva: mapa → ciudad
        agregar: ciudad c × caracteristicas cs × estacion e → ciudad {e ∈ estaciones(mapeo(c)) ∧ₗ ¬esBloqueante(mapeo(c), cs, e)}
        mover: ciudad c × robot r × conexion x → ciudad {esConexionValida(c, r, x)}
        borrar: ciudad c × robot r → ciudad {r ∈ robots(c)}
    otras operaciones
        ultimoId: ciudad c → rur {robots(c) ≠obs ϕ}
        esConexionValida: ciudad c × robot r × conexion → bool
        inspeccion: ciudad c × estacion e → ciudad {e ∈ estaciones(mapeo(c))}
        infracciones: ciudad c × robot r → nat {r ∈ robots(c)}
    axiomas
        mapeo(nueva(m)) ≡ m
        mapeo(agregar(c, r, e)) ≡ mapeo(c)
        mapeo(mover(c, r, e)) ≡ mapeo(c)
        mapeo(borrar(c, r)) ≡ mapeo(c)

        robots(nueva(m)) ≡ ϕ
        robots(agregar(c, cs, e)) ≡
            if ϕ?(robots(c)) then
                { instanciar(1, cs) }
            else
                { instanciar(ultimoId(c) + 1, cs) } ∪ robots(c)
            fi
        robots(mover(c, r, e)) ≡ robots(c)
        robots(borrar(c, r)) ≡ robots(c) - { r }

        historial(agregar(c, r', e), r) ≡
            if id(r) ≡ ultimoId(c) + 1 then
                apilar(⟨e, cars(r')⟩, vacia)
            else
                historial(c, r)
            fi

        historial(mover(c, r', x), r) ≡
            if r ≡ r' then
                apilar(x, historial(c, r))
            else
                historial(c, r)
            fi

        ultimoId(c) ≡ ultimoId'(id(dameUno(robots(c))), sinUno(robots(c)))

        ultimoId': rur × conj(robot) → rur
        ultimoId'(m, c) ≡
            if ϕ?(c) then
                m
            else
                if id(dameUno(c)) > m then
                    ultimoId'(id(dameUno(c)), sinUno(c))
                else
                    ultimoId'(m, sinUno(c))
                fi
            fi

        esConexionValida(c, r, x) ≡
            r ∈ robots(c) ∧ₗ
            π₁(x) ∈ estaciones(mapeo(c)) ∧ₗ
            conectadas(mapeo(c), tope(historial(c, r)), π₁(x)) ∧ₗ
            π₂(x) ∈ caminos(mapeo(c), tope(historial(c, r)), π₁(x))

        inspeccion: ciudad c × estacion e → ciudad {e ∈ estaciones(mapeo(c))}
        inspeccion(c, e) ≡
            if ϕ?(obtenerRobots(c, e)) ∨ₗ 
                isNothing(maxInf(dameUno(obtenerRobots(c, e)), sinUno(obtenerRobots(c, e)))) then
                c
            else
                borrar(c, fromJust(maxInf(dameUno(obtenerRobots(c, e)), sinUno(obtenerRobots(c, e)))))
            fi

        maxInf: ⟨robot, nat⟩ × conj(⟨robot, nat⟩) → maybe(robot)
        maxInf(r, cs) ≡
            if ϕ?(cs) then
                if π₂(r) > 0 then
                    just(π₁(r))
                else
                    nothing
            else
                if π₂(dameUno(cs)) > π₂(r) then
                    maxInf(dameUno(cs), sinUno(cs))
                else
                    maxInf(r, sinUno(cs))
                fi
            fi

        obtenerRobots: ciudad c × estacion e → conj(⟨robot, nat⟩) {e ∈ estaciones(mapeo(c))}
        obtenerRobots(c, e) ≡ obtenerRobots'(c, robots(c), e)

        obtenerRobots': ciudad c × conj(robot) k × estacion e → conj(⟨robot, nat⟩) {k ⊆ robots(c) ∧ e ∈ estaciones(mapeo(c))}
        obtenerRobots'(c, cs, e) ≡
            if ϕ?(cs) then
                ϕ
            else
                if tope(historial(c, dameUno(cs))) ≡ e then
                    ⟨dameUno(cs), infracciones(c, dameUno(cs))⟩ ∪ obtenerRobots'(c, sinUno(cs), e)
                else
                    obtenerRobots'(c, sinUno(cs), e)
                fi
            fi

        infracciones(c, r) ≡ infracciones'(cars(r), historial(c, r))

        infracciones': caracteristicas × pila(conexion) → nat
        infracciones'(c, p) ≡
            if tamaño(p) ≤ 1 then
                0
            else
                if ¬cumple(c, π₂(tope(p))) then
                    1 + infracciones'(c, desapilar(p))
                else
                    infracciones'(c, desapilar(p))
                fi
            fi
Fin TAD
