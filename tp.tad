TAD rur ES nat
TAD caracteristica ES string

TAD Robot
    generos robot
    exporta id, cars, instanciar
    igualdad observacional
        (∀r₁, r₂ : robot) (r₁ =obs r₂ ↔ id(r₁) =obs id(r₂))
    observadores basicos
        id: robot → rur
        cars: robot → conj(caracteristica)
    generadores
        instanciar: rur × conj(caracteristica) → robot
    axiomas
        id(instanciar(r, cs)) ≡ r
        cars(instanciar(r, cs)) ≡ cs
Fin TAD

TAD Restriccion
    generos restriccion
    exporta AND, OR, NOT, VAR, cumple
    igualdad observacional
        (∀ r₁, r₂ : restriccion) (r₁ =obs r₂ ↔
            (∀ c : conj(caracteristica)) (cumple(c, r₁) =obs cumple(c, r₂)))
    observadores basicos
        cumple: conj(caracteristica) × restriccion → bool
    generadores
-- PREGUNTAR deberiamos agregar constantes true y false para hacer caminos que
-- sean siempre/nunca navegables?
        AND: restriccion × restriccion → restriccion
        OR: restriccion × restriccion → restriccion
        NOT: restriccion → restriccion
        VAR: caracteristica → restriccion
    axiomas
        cumple(cs, VAR(c)) ≡ c ∈ cs
        cumple(cs, NOT(c)) ≡ ¬(cumple(cs, c))
        cumple(cs, AND(c1, c2)) ≡ cumple(cs, c1) ∧ cumple(cs, c2)
        cumple(cs, OR(c1, c2)) ≡ cumple(cs, c1) ∨ cumple(cs, c2)
Fin TAD

TAD estacion ES string
TAD conexion ES ⟨estacion, restriccion⟩
TAD conexiones ES conj(conexion)

TAD Mapa
    generos mapa
    exporta estaciones, conexiones, nuevo, crearEst, conectar, esBloqueante, conectadas, caminos
    igualdad observacional
        (∀ m₁, m₂ : mapa) (m₁ =obs m₂ ↔
            estaciones(m₁) =obs estaciones(m₂) ∧ₗ
            (∀ e ∈ estaciones(m₁)) (conexiones(m₁, e) =obs conexiones(m₂, e)))
    observadores basicos
        estaciones: mapa → conj(estacion)
        conexiones: mapa m × estacion e → conj(conexion) {e ∈ estaciones(m)}
    generadores
        nuevo: → mapa
        crearEst: mapa m × estacion a → mapa {a ∉ estaciones(m)}
        conectar: mapa m × estacion a × estacion b × restriccion → mapa {a, b ∈ estaciones(m)}
    otras operaciones
        esBloqueante: mapa m × conj(caracteristica) × estacion e → bool {e ∈ estaciones(m)}
        esBloqueante': conj(conexion) × conj(caracteristica) → bool
        conectadas: mapa m × estacion a × estacion b → bool {a, b ∈ estaciones(m)}
        conectadas': estacion × conj(conexion) → bool
        caminos: mapa m × estacion a × estacion b → conj(restriccion) {a, b ∈ estaciones(m) ∧ conectadas(m, a, b)}
-- PREGUNTAR si deberiamos poner condiciones en esta funcion, aunque pueda funcionar igual
        caminos': estacion × conj(conexion) → conj(restriccion)
    axiomas
        conexiones(crearEst(m, e), k) ≡ ϕ
        conexiones(conectar(m, a, b, r), e) ≡
            if e ≡ a then
                ⟨b, r⟩ ∪ conexiones(m, e)
            else
                if e ≡ b then
                    ⟨a, r⟩ ∪ conexiones(m, e)
                else
                    conexiones(m, e)
                fi
            fi

        estaciones(nuevo) ≡ ϕ
        estaciones(crearEst(m, e)) ≡ { e } ∪ estaciones(m)
        estaciones(conectar(m, a, b)) ≡ estaciones(m)

        esBloqueante(m, r, e) ≡
            if ϕ?(conexiones(m, e)) then
                False
            else
                esBloqueante'(conexiones(m, e), r)
            fi

        esBloqueante'(c, r) ≡
            if ϕ?(c) then
                True
            else
                if cumple(r, π₂(dameUno(c))) then
                    False
                else
                    esBloqueante'(sinUno(c), r)
                fi
            fi

        conectadas(m, a, b) ≡ conectadas'(b, conexiones(m, a))

        conectadas'(a, c) ≡
            if ϕ?(c) then
                False
            else
                if π₁(dameUno(c)) ≡ a then
                    True
                else
                    conectadas'(a, sinUno(c))
                fi
            fi

        caminos(m, a, b) ≡ caminos'(b, conexiones(m, a))

        caminos'(a, c) ≡
            if ϕ?(c) then
                ϕ
            else
                if π₁(dameUno(c)) ≡ a then
                    π₂(dameUno(c)) ∪ caminos'(a, sinUno(c))
                else
                    caminos'(a, sinUno(c))
                fi
            fi
Fin TAD

TAD Ciudad
    generos ciudad
-- PREGUNTAR bien que cosas deberian ir en exporta.
    exporta nueva, agregar, mover, inspeccion
    igualdad observacional
        (∀ c₁, c₂ : ciudad) (c₁ =obs c₂ ↔
            mapeo(c₁) =obs mapeo(c₂) ∧ robots(c₁) =obs robots(c₂) ∧ₗ
            (∀ r ∈ robots(c₁)) (historial(c₁, r) =obs historial(c₂, r)) ∧
-- si exportamos borrar, esto tiene que estar
            ((robots(c₁) ≠obs ϕ) → ultimoId(c₁) =obs ultimoId(c₂)))
    observadores basicos
        mapeo: ciudad → mapa
        robots: ciudad → conj(robot)
        historial: ciudad c × robot r → pila(conexion) {r ∈ robots(c)}
    generadores
        nueva: mapa → ciudad
        agregar: ciudad c × conj(caracteristica) cs × estacion e → ciudad {e ∈ estaciones(mapeo(c)) ∧ₗ ¬esBloqueante(mapeo(c), cs, e)}
        mover: ciudad c × robot r × conexion x → ciudad {esConexionValida(c, r, x)}
        borrar: ciudad c × robot r → ciudad {r ∈ robots(c)}
    otras operaciones
        ultimoId: ciudad c → rur {robots(c) ≠obs ϕ}
        ultimoId': rur × conj(robot) → rur
        esConexionValida: ciudad c × robot r × conexion → bool
        inspeccion: ciudad c × estacion e → ciudad {e ∈ estaciones(mapeo(c))}
        inspeccion': ciudad c × estacion e × ⟨robot, nat⟩ r × conj(⟨robot, nat⟩) k → ciudad {e ∈ estaciones(mapeo(c)) ∧ k ⊆ obtenerRobots(c, e) ∧ r ∈ obtenerRobots(c, e)}
        infracciones: ciudad c × robot r → nat {r ∈ robots(c)}
        infracciones': conj(caracteristica) × pila(conexion) → nat
        obtenerRobots: ciudad c × estacion e → conj(⟨robot, nat⟩) {e ∈ estaciones(mapeo(c))}
        obtenerRobots': ciudad c × conj(robot) k × estacion e → conj(⟨robot, nat⟩) {k ⊆ robots(c) ∧ e ∈ estaciones(mapeo(c))}
    axiomas
        mapeo(nueva(m)) ≡ m
        mapeo(agregar(c, r, e)) ≡ mapeo(c)
        mapeo(mover(c, r, e)) ≡ mapeo(c)
        mapeo(borrar(c, r)) ≡ mapeo(c)

        robots(nueva(m)) ≡ ϕ
        robots(agregar(c, cs, e)) ≡
            if ϕ?(robots(c)) then
                { instanciar(1, cs) }
            else
                { instanciar(ultimoId(c) + 1, cs) } ∪ robots(c)
            fi
        robots(mover(c, r, e)) ≡ robots(c)
        robots(borrar(c, r)) ≡ robots(c) - { r }

        historial(agregar(c, cs, e), r) ≡
            if id(r) ≡ ultimoId(c) + 1 then
                apilar(⟨e, cs⟩, vacia)
            else
                historial(c, r)
            fi

        historial(mover(c, r', x), r) ≡
            if r ≡ r' then
                apilar(x, historial(c, r))
            else
                historial(c, r)
            fi

        ultimoId(c) ≡ ultimoId'(id(dameUno(robots(c))), sinUno(robots(c)))

        ultimoId'(m, c) ≡
            if ϕ?(c) then
                m
            else
                if id(dameUno(c)) > m then
                    ultimoId'(id(dameUno(c)), sinUno(c))
                else
                    ultimoId'(m, sinUno(c))
                fi
            fi

        esConexionValida(c, r, x) ≡
            r ∈ robots(c) ∧ₗ
            π₁(x) ∈ estaciones(mapeo(c)) ∧ₗ
            conectadas(mapeo(c), tope(historial(c, r)), π₁(x)) ∧ₗ
            π₂(x) ∈ caminos(mapeo(c), tope(historial(c, r)), π₁(x))

        inspeccion(c, e) ≡
            if ϕ?(obtenerRobots(c, e)) then
                c
            else
                inspeccion'(c, e, dameUno(obtenerRobots(c, e)), sinUno(obtenerRobots(c, e)))
            fi

        inspeccion'(c, e, r, cs) ≡
            if ϕ?(cs) then
                if π₂(r) > 0 then
                    borrar(c, r)
                else
                    c
                fi
            else
                if π₂(dameUno(cs)) > π₂(r) then
                    inspeccion'(c, e, dameUno(cs), sinUno(cs))
                else
                    inspeccion'(c, e, r, sinUno(cs))
                fi
            fi

        obtenerRobots(c, e) ≡ obtenerRobots'(c, robots(c), e)

        obtenerRobots'(c, cs, e) ≡
            if ϕ?(cs) then
                ϕ
            else
                if tope(historial(c, dameUno(cs))) ≡ e then
                    ⟨dameUno(cs), infracciones(c, dameUno(cs))⟩ ∪ obtenerRobots'(c, sinUno(cs), e)
                else
                    obtenerRobots'(c, sinUno(cs), e)
                fi
            fi

        infracciones(c, r) ≡ infracciones'(cars(r), historial(c, r))

        infracciones'(c, p) ≡
            if tamaño(p) ≤ 1 then
                0
            else
                if ¬cumple(c, π₂(tope(p))) then
                    1 + infracciones'(c, desapilar(p))
                else
                    infracciones'(c, desapilar(p))
                fi
            fi
Fin TAD
