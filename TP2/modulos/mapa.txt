Modulo iMapa

INTERFAZ DEL iMAPA

Se explica con: Mapa

Crear() → res: iMapa
Pre ≡ {true}
Post ≡ {res =obs vacío}
Complejidad: O(1)
Descripcion: Crea un mapa vacío

agregar(in/out m: iMapa, in e: estacion)
Pre ≡ {e ∉ estaciones(m)}
Post ≡ {e ∈ estaciones(m)}
Complejidad: O(#estaciones(m) + |e|)
Descripcion: Agrega una estación al mapa

conectar(in/out m: iMapa, in e1: estacion, in e2: estacion, in r: restriccion)
Pre ≡ {(e1 ∈ estaciones(m) ∧ e2 ∈ estaciones(m)) ∧ₗ ¬conectadas?(m, e1, e2)}
Post ≡ {conectadas?(m, e1, e2) ≡ true}
Complejidad: O(|e1| + |e2| + S)
Descripcion: conecta 2 estaciones del mapa entre con una restriccion para ese vinculo.

estaciones(in m: iMapa) → res: itConj(string)
Pre ≡ {true}
Post ≡ {res =obs ???}
Complejidad: O(1)
Descripcion: Devuelve el conjunto de las estaciones del mapa.

conectadas?(in m: iMapa, in e1: estacion, in e2: estacion) → res: Boolean
Pre ≡ {e1 ∈ estaciones(m) ∧ e2 ∈ estaciones(m)}
Post ≡ {res =obs conectadas?(m, e1, e2)}
Complejidad: O|e1| + |e2|)
Descripcion: Indica si 2 estaciones estan conectadas.

idSenda(in e1: estacion, in e2: estacion) → res: Int
Pre ≡ {(e1 ∈ estaciones(m) ∧ e2 ∈ estaciones(m)) ∧ₗ conectadas?(m, e1, e2)}
Post ≡ {???}
Complejidad: O|e1| + |e2|)
Descripcion: Devuelve el id de la senda entre e1 y e2.

sendas(in m: iMapa) → res: const ?Vector(Restriccion)
Pre ≡ {true}
Post ≡ {res =obs m.sendas}
Complejidad: O(1)
Descripcion: Devuelve las restricciones de las sendas del mapa




iMapa se representa con estr, donde estr es:

tupla(
	   sendas: Vector(Restriccion),
	   conexiones: DiccString(DiccString(Int)),
	   estaciones: conj(string)
	   )

Rep: ^(estr) → boolean

Rep(e) ≡ true ⟺ ( claves(e.conexiones) ⊂ e.estaciones ∧ₗ 
				((∀e1:string) e1 ∈ claves(e.conexiones) ∧ₗ claves(obtener(e1, e.conexiones)) ⊂ e.estaciones ) ∧ₗ
				((∀ e1, e2: string) e1 ∈ claves(e.conexiones) ∧ₗ e2 ∈ claves(obtener(e1, e.conexiones)) ⟺  e2 ∈ claves(e.conexiones) ∧ₗ e1 ∈ claves(obtener(e1, e.conexiones)))  ∧
				((∀ e1, e2: string) e1 ∈ claves(e.conexiones) ∧ₗ e2 ∈ claves(obtener(e1, e.conexiones)) →
				 obtener(e2, obtener(e1, e.conexiones)) < longitud(e.sendas)))

Abs: ^(estr) → iMapa
(∀e : ^(estr)) Abs(e) =obs m: mapa / (e.estaciones =obs estaciones(m)) ∧ 
					((∀ e1, e2: string) (definido?(e.conexiones, e1) ∧ₗ definido?(obtener(e.conexiones, e1), e2)) =obs conectadas?(e1, e2, m))
					∧ ((∀ e1, e2: string) (definido?(e.conexiones, e1) ∧ₗ definido?(obtener(e.conexiones, e1), e2)) → e.sendas[i] =obs restriccion(e1, e2, m))

Algoritmos

Crear() → res: iMapa
	res ← (sendas: Vacia(), conexiones: Vacio(), estaciones: Vacio())

agregar(in/out m: iMapa, in e: estacion)
	Agregar(m.estaciones, e)

conectar(in/out m: iMapa, in e1: estacion, in e2: estacion, in r: restriccion)
	var i: nat ← Longitud(m.sendas)
	AgregarAtras(m.sendas, r)
	if ¬definido?(m.conexiones, e1) then 
		definir(m.conexiones, e1, Vacio())
	end if
	if ¬definido?(m.conexiones, e2) then 
		definir(m.conexiones, e2, Vacio())
	end if

	definir(obtener(m.conexiones, e1), e2, i)
	definir(obtener(m.conexiones, e2), e1, i)


estaciones(in m: iMapa) → res: itConj(string)
	res ← CrearIt(m.estaciones)

conectadas?(in m: iMapa, in e1: estacion, in e2: estacion) → res: Boolean
	res ← definido?(m.conexiones, e1) ∧ₗ definido?(obtener(m.conexiones, e1), e2)

idSenda(in e1: estacion, in e2: estacion) → res: Int
	res ← obtener(obtener(m.conexiones, e1), e2)

sendas(in m: iMapa) → res: const ?Vector(Restriccion)
	iterador solo lectura?