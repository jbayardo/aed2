PREGUNTAR:
	Se necesita borrar y #Claves? claramente no peroooo hay que algoritmearlo igual porque es un dicc?

MODULO DiccString(α)

INTERFAZ

	Parametros formales
		generos α
		funcion ∙ = ∙ (in a1 : α, a2 : α) → res : bool
			Pre ≡ {true}
			Post ≡ {res =obs (a1 = a2)}
			Complejidad: O(equal(a1, a2))
			Descripcion: funcion de igualdad de αs

	Se explica con: dicc(string, α)
	Generos: DiccString(α)

	Crear() → res : DiccString(α)
	Pre ≡ {true}
	Post ≡ {res =obs vacio}
	Complejidad: O(1)
	Descripcion: Crea un diccionario vacio.

	Insertar(in/out d : DiccString(α), in k : string, in v : α)
	Pre ≡ {d =obs d₀}
	Post ≡ {d =obs definir(k, v, d₀)}
	Complejidad: O(|k|)
	Descripcion: Inserta una clave en el diccionario.

	NO	#Borrar(in/out d : DiccString(α), in k : string)
	VA	#Pre ≡ {def?(k, d) ∧ d =obs d₀}
		#Post ≡ {d =obs borrar(k, d₀)}
		#Complejidad: O(|k|)
		#Descripcion: Borra una clave del diccionario.

	Definido?(in d : DiccString(α), in k : string) → res : bool
	Pre ≡ {true}
	Post ≡ {res =obs def?(k, d)}
	Complejidad: O(|k|)
	Descripcion: Dice si una clave esta definido.

	Obtener(in d : DiccString(α), in k : string) → res : α
	Pre ≡ {def?(k, d)}
	Post ≡ {res =obs obtener(k, d)}
	Complejidad: O(|k|)
	Descripcion: Obtiene el significado de la clave en el diccionario

	NO	##Claves(in d : DiccString(α)) → res : nat
	VA	#Pre ≡ {true}
		#Post ≡ {res =obs #claves(d)}
		#Complejidad: O(1)
		#Descripcion: Devuelve la cantidad de claves definidas en el diccionario.

REPRESENTACION

	DiccString(α) se representa con trie, donde trie es:
		tupla(
				continuacion: array_estatico[256] de puntero(trie),
				significado: α,
				definido: bool
				)
			
	Rep : trie t -> bool
		Rep(t) ≡  !π₃(t) ɅL ((Vp1, p2 puntero є {aplanar(π₁(t),0)}) if p1 != p2 then *p1 != *p2 fi Ʌ *p1 != t) 

	aplanar: array_estatico[256] de puntero(trie) -> secu(puntero(trie))
		aplanar(a,n) ≡ 
			if n < 255 then
				if a[n] = null then 
					aplanar(a,n+1)
				else
					aplanar(*a[n], 0) & aplanar(a,n+1)
			else
				<>
			fi

	Abs : trie t -> dicc(string; nat) {Rep(t)}
		Abs(t) ≡ Abs'(t, 0, <>)
		
		Abs'(t,n,s) ≡
			if n < 256 then
				if π₁(t)[n] != NULL then
					if π₃( *( π₁(t)[n] ) ) then 
						unirD( definir(s, π₂( *(π₁(t)[n]) ), abs'(*(π₁(t)[n]), 0, s ○ n)), abs'(t, n+1, s))
					else
						unirD( abs'(*(π₁(t)[n]), 0, s ○ n), abs'(t, n+1, s))
					fi
				else
					abs'(t, n+1, s)
				fi
			else
				vacio
			fi
		
		unirD(d, d') ≡
			if(Ø?(claves(d'))) then
				d
			else
				definir(dameuno(claves(d')), obtener(dameuno(claves(d'))), unirD(d, borrar(dameuno(claves(d')), d')))
			fi
	
ABS CARACTERIZADO
	Abs : trie t -> dicc(string; nat) {Rep(t)}
	(∀t : trie) Abs(t) =obs d:dicc(c, s) /
		Def?(c, d) =obs if (t = null) then
					false
				else
					if (vacio?(c)) then
						if (t.definido)
							true
						else
							false
					else
						def?(fin(c), *t.continuacion[prim(c)])
					fi
				fi
		∧ 
		obtener(c, d) =obs 	if (t.definido ∧ vacio?(c)) then
						t.significado
					else
						obtener(fin(c), *t.continuacion[prim(c)])
					fi
	
ALGORITMOS
		DiccString(α) se representa con trie, donde trie es:
		tupla(
			continuacion: array_estatico[256] de puntero(trie),
			significado: α,
			definido: bool
		)
			
	Crear() → res : DiccString(α)
		res <- (continuacion: CREARARREGLO(256), definido: False) // y significado???
		
	Insertar(in/out d : DiccString(α), in k : string, in v : α)
		if vacia?(k) then 
			d.definido = True
			d.significado = v
		else
			if d.continuacion[prim(k)] == NULL
				d.continuacion[prim(k)] = *Crear()
			fi
			Insertar(d.continuacion[prim(k)], fin(k), v)
		fi
	
	Definido?(in d : DiccString(α), in k : string) → res : bool
		if vacia?(k) then
			res ← d.definido
		else
			definido?(d.continuacion[prim(k)], fin(k))
		fi
		
	Obtener(in d : DiccString(α), in k : string) → res : α
		if vacia?(k) then
			res ← d.significado
		else
			obtener(d.continuacion[prim(k)], fin(k))
		fi
	
