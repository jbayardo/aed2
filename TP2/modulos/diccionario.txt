PREGUNTAR:
	En iCrear() que hacer con significado, usar punteros?

********************************************************************************
************						 Interfaz 						************
********************************************************************************

Parametros formales
	generos α
	funcion ∙ = ∙ (in a1 : α, a2 : α) → res : bool
		Pre ≡ {true}
		Post ≡ {res =obs (a1 = a2)}
		Complejidad: O(equal(a1, a2))
		Descripcion: funcion de igualdad de αs

Se explica con: dicc(string, α)
Generos: DiccString(α)

********************************************************************************
************					   Operaciones 						************
********************************************************************************

Crear() → res : DiccString(α)
Pre ≡ {true}
Post ≡ {res =obs vacio}
Complejidad: O(1)
Descripcion: Crea un diccionario vacio.

Definir(in/out d : DiccString(α), in k : string, in v : α)
Pre ≡ {d =obs d₀}
Post ≡ {d =obs definir(k, v, d₀)}
Complejidad: O(|k|)
Descripcion: Inserta una clave en el diccionario.

Definido?(in d : DiccString(α), in k : string) → res : bool
Pre ≡ {true}
Post ≡ {res =obs def?(k, d)}
Complejidad: O(|k|)
Descripcion: Dice si una clave esta definido.

Obtener(in d : DiccString(α), in k : string) → res : α
Pre ≡ {def?(k, d)}
Post ≡ {res =obs obtener(k, d)}
Complejidad: O(|k|)
Descripcion: Obtiene el significado de la clave en el diccionario

********************************************************************************
************					 Representación						************
********************************************************************************

DiccString(α) se representa con trie(α)
	donde trie(α) es tupla(
						continuacion : array_estatico[256] de puntero(trie(α)),
						significado	 : α,
						definido     : bool)

Rep: trie(α) t → bool
Rep(t) ≡ true ⟺ ¬π₃(t) ∧ₗ
	((∀p1, p2 : puntero ∈ {aplanar(π₁(t), 0)}) (
		 ¬(p1 =obs p2) ⟹ₗ ¬(*p1 =obs *p2)
	) ∧
	*p1 != t)

aplanar: array_estatico[256] de puntero(trie) → secu(puntero(trie))
aplanar(a,n) ≡
	if n >= 255 then
		<>
	else
		if a[n] == null then
			aplanar(a, n+1)
		else
			(aplanar(*a[n], 0) & aplanar(a, n+1)) ◦ a[n]
		fi
	fi

Abs: ^(trie(α)) t → dicc(string, α)										{Rep(t)}
(∀t : ^(trie(α))) Abs(t) =obs d /
	Def?(c, d) =obs
		if (t == null) then
			false
		else
			if vacio?(c) then
				t.definido
			else
				def?(fin(c), *t.continuacion[prim(c)])
			fi
		fi
	∧ Def?(c, d) ⟹ₗ
		obtener(c, d) =obs
			if vacio?(c) then
				t.significado
			else
				obtener(fin(c), *t.continuacion[prim(c)])
			fi

********************************************************************************
************					  Algoritmos						************
********************************************************************************

iCrear() → res : trie(α)
	res <- ⟨continuacion: CREARARREGLO(256), definido: False⟩ // y significado??? // No lo poniamos y listo??????
end function

iDefinir(in/out d : trie(α), in k : string, in v : α)
	if vacia?(k) then
		d.definido    <- True
		d.significado <- v
	else
		if  d.continuacion[prim(k)] == NULL then
			d.continuacion[prim(k)] = &Crear()
		end if
		Definir(d.continuacion[prim(k)], fin(k), v)
	end if
end function

iDefinido?(in d : trie(α), in k : string) → res : bool
	if vacia?(k) then
		res ← d.definido
	else
		Definido?(d.continuacion[prim(k)], fin(k))
	end if
end function

iObtener(in d : trie(α), in k : string) → res : α
	if vacia?(k) then
		res ← d.significado
	else
		Obtener(d.continuacion[prim(k)], fin(k))
	end if
end function
