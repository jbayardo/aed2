PREGUNTAR:
	En iCrear() que hacer con significado, usar punteros?

MODULO DiccString(α)

********************************************************************************
************						 Interfaz 						************
********************************************************************************

Parametros formales
	generos α
	funcion ∙ = ∙ (in a1 : α, a2 : α) → res : bool
		Pre ≡ {true}
		Post ≡ {res =obs (a1 = a2)}
		Complejidad: O(equal(a1, a2))
		Descripcion: funcion de igualdad de αs

Se explica con: dicc(string, α)
Generos: DiccString(α)

********************************************************************************
************					   Operaciones 						************
********************************************************************************

Crear() → res : DiccString(α)
Pre ≡ {true}
Post ≡ {res =obs vacio}
Complejidad: O(1)
Descripcion: Crea un diccionario vacio.

definir(in/out d : DiccString(α), in k : string, in v : α)
Pre ≡ {d =obs d₀}
Post ≡ {d =obs definir(k, v, d₀)}
Complejidad: O(|k|)
Descripcion: Inserta una clave en el diccionario.

Definido?(in d : DiccString(α), in k : string) → res : bool
Pre ≡ {true}
Post ≡ {res =obs def?(k, d)}
Complejidad: O(|k|)
Descripcion: Dice si una clave esta definido.

Obtener(in d : DiccString(α), in k : string) → res : α
Pre ≡ {def?(k, d)}
Post ≡ {res =obs obtener(k, d)}
Complejidad: O(|k|)
Descripcion: Obtiene el significado de la clave en el diccionario

********************************************************************************
************					 Representación						************
********************************************************************************

DiccString(α) se representa con trie
	donde trie es tupla(
					continuacion : array_estatico[256] de puntero(trie),
					significado	 : α,
					definido     : bool)

Rep : trie t → bool
Rep(t) ≡ true ⟺ !π₃(t) ɅL
	((∀ p1, p2 : puntero є {aplanar(π₁(t), 0)}) (
		 p1 !=  p2 ⟹ₗ
		*p1 != *p2
	)Ʌ
	*p1 != t)

aplanar: array_estatico[256] de puntero(trie) → secu(puntero(trie))
aplanar(a,n) ≡
	if n >= 255 then
		<>
	else
		if a[n] == null then
			aplanar(a, n+1)
		else
			(aplanar(*a[n], 0) & aplanar(a, n+1)) ◦ a[n]
		fi
	fi

Abs : trie t → dicc(string; α) {Rep(t)}
(∀t : trie) Abs(t) =obs d:dicc(c, s) /
	Def?(c, d) =obs 
		if (t == null) then
			false
		else
			if vacio?(c) then
				t.definido
			else
				def?(fin(c), *t.continuacion[prim(c)])
			fi
		fi
	∧ Def?(c, d) ⟹ₗ
	obtener(c, d) =obs 
		if vacio?(c) then
			t.significado
		else
			obtener(fin(c), *t.continuacion[prim(c)])
		fi

********************************************************************************
************					  Algoritmos						************
********************************************************************************

DiccString(α) se representa con trie, donde trie es:
	tupla(
		continuacion : array_estatico[256] de puntero(trie),
		significado  : α,
		definido     : bool
	)

iCrear() → res : DiccString(α)
	res <- (continuacion: CREARARREGLO(256), definido: False) // y significado??? // No lo poniamos y listo??????

idefinir(in/out d : DiccString(α), in k : string, in v : α)
	if vacia?(k) then
		d.definido    <- True
		d.significado <- v
	else
		if  d.continuacion[prim(k)] == NULL then
			d.continuacion[prim(k)] = &Crear()
		end if
		definir(d.continuacion[prim(k)], fin(k), v)
	end if

iDefinido?(in d : DiccString(α), in k : string) → res : bool
	if vacia?(k) then
		res ← d.definido
	else
		definido?(d.continuacion[prim(k)], fin(k))
	end if

iObtener(in d : DiccString(α), in k : string) → res : α
	if vacia?(k) then
		res ← d.significado
	else
		obtener(d.continuacion[prim(k)], fin(k))
	end if


