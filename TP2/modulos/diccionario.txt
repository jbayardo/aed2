PREGUNTAR:
	En iCrear() que hacer con significado, usar punteros?

********************************************************************************
************						 Interfaz 						************
********************************************************************************

Parametros formales
	generos α
	funcion ∙ = ∙ (in a1 : α, a2 : α) → res : bool
		Pre ≡ {true}
		Post ≡ {res =obs (a1 = a2)}
		Complejidad: O(equal(a1, a2))
		Descripcion: funcion de igualdad de αs

Se explica con: dicc(string, α)
Generos: DiccString(α)

********************************************************************************
************					   Operaciones 						************
********************************************************************************

Crear() → res : DiccString(α)
Pre ≡ {true}
Post ≡ {res =obs vacio}
Complejidad: O(1)
Descripcion: Crea un diccionario vacio.

Definir(in/out d : DiccString(α), in k : string, in v : α)
Pre ≡ {d =obs d₀}
Post ≡ {d =obs definir(k, v, d₀)}
Complejidad: O(|k|)
Descripcion: Inserta una clave en el diccionario.

Definido?(in d : DiccString(α), in k : string) → res : bool
Pre ≡ {true}
Post ≡ {res =obs def?(k, d)}
Complejidad: O(|k|)
Descripcion: Dice si una clave esta definido.

Obtener(in d : DiccString(α), in k : string) → res : α
Pre ≡ {def?(k, d)}
Post ≡ {res =obs obtener(k, d)}
Complejidad: O(|k|)
Descripcion: Obtiene el significado de la clave en el diccionario

********************************************************************************
************					 Representación						************
********************************************************************************

DiccString(α) se representa con trie(α)
	donde trie(α) es tupla(
						continuacion : array_estatico[256] de puntero(trie(α)),
						significado	 : α,
						definido     : bool)

Rep: trie(α) t → bool
Rep(t) ≡ true ⟺ ¬π₃(t) ∧ₗ
	((∀p1, p2 : puntero ∈ {aplanar(π₁(t), 0)}) (
		 ¬(p1 =obs p2) ⟹ₗ ¬(*p1 =obs *p2)
	) ∧
	*p1 != t)

aplanar: array_estatico[256] de puntero(trie) → secu(puntero(trie))
aplanar(a,n) ≡
	if n >= 255 then
		<>
	else
		if a[n] == null then
			aplanar(a, n+1)
		else
			(aplanar(*a[n], 0) & aplanar(a, n+1)) ◦ a[n]
		fi
	fi

Abs: ^(trie(α)) t → dicc(string, α)										{Rep(t)}
(∀t : ^(trie(α))) Abs(t) =obs d /
	Def?(c, d) =obs
		if (t == null) then
			false
		else
			if vacio?(c) then
				t.definido
			else
				def?(fin(c), *t.continuacion[prim(c)])
			fi
		fi
	∧ Def?(c, d) ⟹ₗ
		obtener(c, d) =obs
			if vacio?(c) then
				t.significado
			else
				obtener(fin(c), *t.continuacion[prim(c)])
			fi

********************************************************************************
************					  Algoritmos						************
********************************************************************************

iCrear() → res : trie(α)
	res <- ⟨continuacion: CREARARREGLO(256), definido: False⟩ // y significado??? // No lo poniamos y listo??????
end function

iDefinir(in/out d : trie(α), in k : string, in v : α)
	while !vacia?(k) do
		if d.continuacion[prim(k)] == NULL then
			d.continuacion[prim(k)] ← &Crear()
		end if
		d ← d.continuacion[prim(k)]
		k ← fin(k)
	end while
	d.definido 	  ← true
	d.significado ← v
end function

Como se puede observar el bucle principal depende exlusivamente de la cantidad de caracteres del arreglo, por lo que el mejor caso es que el mismo tenga 0 caracteres en donde automaticamente saldra y definira la palabra vacia y su costo sera O(1), pero tanto el caso promedio como el peor sera en donde el largo del arreglo es mayor a 0 entonces dado que todas las operaciones dentro del bucle tienen costo O(1) tendra un costo equivalente al tamaño del arreglo (O(|k|)) ya que tendra que recorrerlo para definir letra por letra dentro de la estructura hasta llegar a su fin y definir el significado que tardara solo 1 operacion

iDefinido?(in d : trie(α), in k : string) → res : bool
	while !vacia(k) do
		d ← d.continuacion[prim(k)]
		k ← fin(k)
	end while
	res ← d.definido
end function

En el peor caso(si el arreglo esta definido dentro de la estructura y el mismo tiene largo mayor a 0) dado que las operaciones dentro del bucle tienen costo O(1) y se repetiran |k| veces, para ir recorriendo la estructura, este tendra un costo O(|k|) pero en el caso de que no este definido el costo sera O(|k| - n) con n cantidad de caracteres que no pertenecen al prefijo perteneciente a la estructura por lo que el peor caso sera O(|k|)

iObtener(in d : trie(α), in k : string) → res : α
	while !vacia(k) do
		d ← d.continuacion[prim(k)]
		k ← fin(k)
	end while
	res ← d.significado
end function
Se explica igual que iDefinido
