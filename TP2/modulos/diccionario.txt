********************************************************************************
************						 Interfaz 						************
********************************************************************************

Parametros formales
	generos α
	funcion ∙ = ∙ (in a1 : α, a2 : α) → res : bool
		Pre ≡ {true}
		Post ≡ {res =obs (a1 = a2)}
		Complejidad: O(equal(a1, a2))
		Descripcion: funcion de igualdad de αs

Se explica con: dicc(string, α)
Generos: DiccString(α)

********************************************************************************
************					   Operaciones 						************
********************************************************************************

Crear() → res : DiccString(α)
Pre ≡ {true}
Post ≡ {res =obs vacio}
Complejidad: O(1)
Descripcion: Crea un diccionario vacio.

Definir(in/out d : DiccString(α), in k : string, in v : α)
Pre ≡ {d =obs d₀}
Post ≡ {d =obs definir(k, v, d₀)}
Complejidad: O(long(k))
Descripcion: Inserta una clave en el diccionario.

Definido?(in d : DiccString(α), in k : string) → res : bool
Pre ≡ {true}
Post ≡ {res =obs def?(k, d)}
Complejidad: O(long(k))
Descripcion: Dice si una clave esta definido.

Obtener(in d : DiccString(α), in k : string) → res : α
Pre ≡ {def?(k, d)}
Post ≡ {res =obs obtener(k, d)}
Complejidad: O(long(k))
Descripcion: Obtiene el significado de la clave en el diccionario

********************************************************************************
************					 Representación						************
********************************************************************************

DiccString(α) se representa con trie(α)
	donde trie(α) es tupla(
						continuacion : array_estatico[256] de puntero(trie(α)),
						significado	 : puntero(α)
						)


Rep: trie(α) t → bool
Rep(t) ≡ true ⟺
	No hay ciclos ∧
	((∀i : nat) (i < 256) ⟹ₗ t.continuacion[i] =obs NULL) ⟹ t.significado =obs NULL ∧ₗ
	(∀i : nat) (i < 256 ∧ₗ ¬(t.continuacion[i] =obs NULL)) ⟹ₗ Rep(*(t.continuacion[i]))

Abs: ^(trie(α)) t → dicc(string, α)										{Rep(t)}
(∀t : ^(trie(α))) Abs(t) =obs d /
	(∀c : string)
		def?(c, d) =obs def'?(c, t, 0) ∧
		def'?(c, t, 0) ⟹ₗ obt'(c, t, 0) =obs obtener(c, d)

def?': string s × ^(trie(α)) t × nat n → bool
def?'(s, t, n) ≡
	if n >= Longitud(s) - 1 then ¬(t.significado =obs NULL)
	else
		if t.continuacion[ord(s[n])] =obs NULL then false
		else def?(s, t.continuacion[ord(s[n])], n+1) fi
	fi

obt': string s × ^(trie(α)) t × nat n → α 									{def'?(s, t)}
obt'(s, t, n) ≡
	if n >= Longitud(s) - 1 then t.significado
	else
		obt'(s, t.continuacion[ord(s[n])], n+1)
	fi

********************************************************************************
************					  Algoritmos						************
********************************************************************************

iCrear() → res : trie(α)
	res <- ⟨continuacion: CREARARREGLO(256), significado: NULL⟩
end function

iDefinir(in/out d : trie(α), in k : string, in v : α)
	nat i ← 0
	puntero(trie(α)) t ← d
	while i < longitud(k) do
		if t.continuacion[ord(k[i])] == NULL then
			t.continuacion[ord(k[i])] ← &Crear()
		end if
		t ← t.continuacion[ord(k[i])]
		i ← i + 1
	end while
	t.significado ← &v
end function

Como se puede observar el bucle principal depende exlusivamente de la cantidad de
caracteres del vector, por lo que el mejor caso es que el mismo tenga 0 caracteres
en donde automaticamente saldra y definira la palabra vacia y su costo sera O(1),
pero tanto el caso promedio como el peor sera en donde el largo del vector es mayor
a 0 entonces dado que todas las operaciones dentro del bucle tienen costo O(1)
tendra un costo equivalente al tamaño del vector (O(long(k))) ya que tendra que
recorrerlo para definir letra por letra dentro de la estructura hasta llegar a su
fin y definir el significado que tiene costo O(1).

iDefinido?(in d : trie(α), in k : string) → res : bool
	nat i ← 0
	puntero(trie(α)) t ← d
	bool listo ← False
	while i < longitud(k) ∧ t.continuacion[ord(k[i])] != NULL do
		t ← t.continuacion[ord(k[i])]
		i ← i + 1
	end while
	res ← t.significado != NULL ∧ i == longitud(k)
end function

En el peor caso(si el string esta definido dentro de la estructura y el mismo
tiene largo mayor a 0) dado que las operaciones dentro del bucle tienen costo O(1)
y se repetiran long(k) veces, para ir recorriendo la estructura, este tendra un costo
O(long(k)) pero en el caso de que no este definido el costo sera O(long(k) - n) con n
cantidad de caracteres que no pertenecen al prefijo perteneciente a la estructura
por lo que el peor caso sera O(long(k)).

iObtener(in d : trie(α), in k : string) → res : α
	var i : nat ← 0
	puntero(trie(α)) t ← d
	while i < longitud(k) do
		t ← t.continuacion[ord(k[i])]
		i ← i + 1
	end while
	res ← *t.significado
end function

En el peor caso dado que las operaciones dentro del bucle tienen costo O(1)
y se repetiran long(k) veces, para ir recorriendo la estructura, este tendra un costo
O(long(k)).
