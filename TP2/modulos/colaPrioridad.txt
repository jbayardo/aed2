MODULO COLA DE PRIORIDAD

Interfaz

Parametros Formales
	géneros α
	función ∙ < ∙ (in a1 : α, a2 : α) → res : bool
		Pre ≡ {true}
		Post ≡ {res =obs (a1 < a2)}
		Complejidad: O(lower(a1, a2))
		Descripción: funcion de comparación de αs

	función ∙ > ∙ (in a1 : α, a2 : α) → res : bool
		Pre ≡ {true}
		Post ≡ {res =obs (a1 > a2)}
		Complejidad: O(higher(a1, a2))
		Descripción: funcion de comparación de αs

Se explica con: ColaDePrioridadExtendida(α), IteradorUnidireccionalModificable(α)
Generos: ColaPrioridad(α), itCola(α)

************************** Operaciones de la cola ******************************

Crear() → res : ColaPrioridad(α)
Pre ≡ {true}
Post ≡ {res =obs vacia}
Complejidad: O(1)
Descripción: Crea una cola vacia.

Encolar(in/out t : ColaPrioridad(α), in e : α) → res : itCola(α)
Pre ≡ {¬(e ∈ t) ∧ t₀ =obs t}
Post ≡ {t =obs encolar(e, t₀) ∧ Actual(res) =obs e}
Complejidad: O(log(#t))
Descripción: Inserta un elemento en la cola y devuelve un iterador posicionado en el elemento agregado.

Desencolar(in/out t : ColaPrioridad(α)) → res : α
Pre ≡ {¬vacia?(t) ∧ t =obs t₀}
Post ≡ {t =obs desencolar(t₀) ∧ res =obs proximo(t₀)}
Complejidad: O(log(#t))
Descripción: Desencola el elemento con mayor prioridad.

Tamaño(in t : ColaPrioridad(α)) → res : nat
Pre ≡ {true}
Post ≡ {res =obs #t}
Complejidad: O(1)
Descripción: Devuelve la cantidad de elementos en la cola.

TAD ColaDePrioridadExtendida(α)
	extiende colaPrior(α)
	otras operaciones (exportadas)
		#∙ : colaPrior(α) → nat
		∙ ∈ ∙ : α × colaPrior(α) → bool
		borrar : α e × colaPrior(α) c → colaPrior(α) {e ∈ c}
	axiomas
		#c ≡ if vacia?(c) then 0 else 1 + #desencolar(c) fi
		x ∈ c ≡ ¬vacia?(c) ∧ₗ (x =obs proximo(c) ∨ₗ x ∈ desencolar(c))
		borrar(e, c) ≡
			if e =obs proximo(c) then
				if e ∈ desencolar(c) then borrar(e, desencolar(c))
				else desencolar(c) fi
			else encolar(proximo(c), borrar(e, desencolar(c))) fi
Fin TAD

**************************** Operaciones del Iterador **************************

CrearIt(in t : ColaPrioridad(α)) → res : itCola(α)
Pre ≡ {true}
Post ≡ {res =obs }
Complejidad: O(1)
Descripción: Crea un iterador unidireccional modificable de la cola, de forma
tal que al pedir Siguiente se obtenga el proximo elemento a desencolar.
Aliasing: ????????????????????

HaySiguiente(in t : itCola(α)) → res : bool
Pre ≡ {true}
Post ≡ {res =obs HayMas?(t)}
Complejidad: O(1)
Descripción: Se fija si hay más elementos para recorrer.

Siguiente(in/out t : itCola(α))
Pre ≡ {HayMas?(t) ∧ t₀ =obs t}
Post ≡ {t =obs Avanzar(t₀)}
Complejidad: O(1)
Descripción: Avanza el iterador en una posición.

Actual(in t : itCola(α)) → res : α
Pre ≡ {HayMas?(t)}
Post ≡ {res =obs Actual(t)}
Complejidad: O(1)
Descripción: Devuelve el elemento al que apunta el iterador en el momento.

NECESITO HABLAR DE LA COLA QUE ESTA POR DEBAJO DEL ITERADOR PARA DECIR QUE LE BORRE
EL ELEMENTO AL QUE APUNTABA EN EL MOMENTO, COMO HAGO?

Borrar(in/out t : itCola(α))
Pre ≡ {HayMas?(t) ∧ t₀ =obs t}
Post ≡ {t =obs Eliminar(t₀)}
Complejidad: O(1)
Descripción: Elimina el elemento actual de la cola de prioridad.

Representación

ColaPrioridad(α) se representa con estr(α)
	donde estr(α) es tupla(cabeza: puntero(nodo(α)), ultimo: puntero(nodo(α)), tamaño: nat)
	donde nodo(α) es tupla(arr: puntero(nodo(α)), izq: puntero(nodo(α)), der: puntero(nodo(α)), dato: α)

Rep: ^(estr(α)) → boolean
Rep(e) ≡ true ⟺
	(e.cabeza =obs NULL ⟺ e.tamaño =obs 0 ⟺ e.ultimo =obs NULL) ∧
	InvPadres(e.cab) ∧
	No hay ciclos en el arbol ∧ₗ
	MaxHeap(e.cab) ∧
	El arbol es completo e izquierdista ∧ₗ
	(¬(e.cabeza =obs NULL) ⟹ₗ
		e.cabeza→arr =obs NULL ∧
		e.tamaño = tamaño(e.cabeza) ∧
		e.ultimo ES VALIDO)

InvPadres: puntero(nodo(α)) → bool
InvPadres(p) ≡
	if p =obs NULL then true
	else
		(¬(p→izq =obs NULL) ⟹ₗ p→izq→arr =obs p) ∧
		(¬(p→der =obs NULL) ⟹ₗ p→der→arr =obs p) ∧
		InvPadres(p→izq) ∧
		InvPadres(p→der)
	fi

MaxHeap: puntero(nodo(α)) → bool
MaxHeap(p) ≡
	if p =obs NULL then true
	else
		(¬(p→izq =obs NULL) ⟹ₗ p→izq→dato < p→dato) ∧
		(¬(p→der =obs NULL) ⟹ₗ p→der→dato < p→dato) ∧
		MaxHeap(p→izq) ∧
		MaxHeap(p→der)
	fi

tamaño: puntero(nodo(α)) → nat
tamaño(p) ≡ if p =obs NULL then 0 else 1 + tamaño(p→izq) + tamaño(p→der) fi

//////////////////////////// VER BIEN EL TEMA DEL ABS  /////////////////////////

Abs: ^(estr(α)) → ColaDePrioridadExtendida(α)
(∀e : ^(estr(α))) Abs(e) =obs t /
	vacia?(t) =obs (e.tam =obs 0) ∧
	¬vacia?(t) ⟹ₗ
		proximo(t) =obs e.cab→dato ∧
		desencolar(t) =obs ....?

////////////////////// REVISAR SI CREAR ESTA BIEN
Crear() → res : ColaPrioridad(α)
	res ← ⟨cabeza: NULL, ultimo: NULL, tamaño: 0⟩
end function

Tamaño(in t : ColaPrioridad(α)) → res : nat
	res ← t.tamaño
end function

Encolar(in/out t : ColaPrioridad(α), in e : α) → res : itCola(α)
	var tmp : puntero(nodo(α)) ← NULL

	tmp = ??????????????????? MEMORY ALLOCATIONNNN
	tmp→dato ← e
	tmp→izq ← NULL
	tmp→der ← NULL

	if Tamaño(t) == 0 then
		tmp→arr ← NULL
		t.cabeza ← tmp
	else if Tamaño(t) == 1 then
		tmp→arr ← t.cabeza
		t.cabeza→izq ← tmp
	else
		if t.ultimo→arr→izq == t.ultimo then
			tmp→arr ← t.ultimo→arr
			t.ultimo→arr→der ← tmp
		else
			var cur : puntero(nodo(α)) ← t.ultimo

			ESTE ES EL CASO EN EL QUE ESTAMOS A LA DERECHA Y HAY QUE
			ENCONTRAR ALGO ARRIBA DE TODO
			TERMINARRRRRRRRRRRRr----------------------------------------------
		end if
	end if

	t.ultimo ← tmp
	t.tamaño++

	Subir(t.ultimo)
	res ← crearIter(t, p)
end function

Desencolar(in/out t : ColaPrioridad(α)) → res : α
	res ← t.cabeza→dato

	if Tamaño(t) == 1 then
		free(t.cabeza)
		t.ultimo ← NULL
		t.cabeza ← NULL
	else
		var proximo : puntero(nodo(α)) ← ProximoUltimo(t)
		t.cabeza→dato ← t.ultimo→dato

		if t.ultimo→arr→izq == t.ultimo then
			t.ultimo→arr→izq ← NULL
		else
			t.ultimo→arr→der ← NULL
		end if

		free(t.ultimo) ????????????????????????????????????????????????????????
		t.ultimo ← proximo
		Bajar(t.cabeza)
	end if

	t.tamaño--
end function

////////////////////////////// A ESTAS 3 ULTIMAS LES FALTA LAS PRE Y POS ///////

ProximoUltimo(in t : ColaPrioridad(α)) → res : puntero(nodo(α))
	IMPLEMENTAR LA FUNCION DE BUSQUEDA DEL PROXIMO ULTIMO
end function

// PRE: p != NULL
// POST: se restablecio el rep
// REVISAR EL TEMA ESTE DE QUE SEA DE TIPO α SIN QUE ESTE CLARO QUE VERGA ES α
Subir(in/out p : puntero(nodo(α)))
	while p→arr != NULL ∧ p→arr→dato < p→dato do
		var tmp : α ← p→arr→dato
		p→arr→dato ← p→dato
		p→dato ← tmp
		p ← p→arr
	end while
end function

// PRE: p != NULL
// Post: se restablecio el rep
// REVISAR EL TEMA ESTE DE QUE SEA DE TIPO α SIN QUE ESTE CLARO QUE VERGA ES α
Bajar(in/out p : puntero(nodo(α)))
	while	(p→izq != NULL ∧ p→izq→dato > p→dato) ∨
			(p→der != NULL ∧ p→der→dato < p→dato) do
		if p→izq != NULL then
			var tmp : α ← p→izq→dato
			p→izq→dato ← p→dato
			p→dato ← tmp
		else
			if p→der != NULL then
				var tmp : α ← p→der→dato
				p→der→dato ← p→dato
				p→dato ← p→der→dato
			end if
		end if
	end while
end function
