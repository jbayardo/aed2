MODULO COLA DE PRIORIDAD

INTERFAZ DE LA COLA

Parametros Formales
	géneros α
	función ∙ < ∙ (in a1 : α, a2 : α) → res : bool
		Pre ≡ {true}
		Post ≡ {res =obs (a1 < a2)}
		Complejidad: O(lower(a1, a2))
		Descripción: funcion de comparación de αs

	función ∙ > ∙ (in a1 : α, a2 : α) → res : bool
		Pre ≡ {true}
		Post ≡ {res =obs (a1 > a2)}
		Complejidad: O(higher(a1, a2))
		Descripción: funcion de comparación de αs

	función ∙ = ∙ (in a1 : α, a2 : α) → res : bool
		Pre ≡ {true}
		Post ≡ {res =obs (a1 = a2)}
		Complejidad: O(equal(a1, a2))
		Descripción: funcion de comparación de αs

Se explica con: ColaDePrioridadExtendida(α)
Generos: ColaPrioridad(α)

Crear() → res : ColaPrioridad(α)
Pre ≡ {true}
Post ≡ {res =obs vacia}
Complejidad: O(1)
Descripción: Crea una cola vacia.

Encolar(in/out t : ColaPrioridad(α), in e : α) → res : itCola(α)
Pre ≡ {¬(e ∈ t) ∧ t₀ =obs t}
Post ≡ {t =obs encolar(e, t₀) ∧ Actual(res) =obs e}
Complejidad: O(log(#t))
Descripción: Inserta un elemento en la cola y devuelve un iterador posicionado en el elemento agregado.

Desencolar(in/out t : ColaPrioridad(α)) → res : α
Pre ≡ {¬vacia?(t) ∧ t =obs t₀}
Post ≡ {t =obs desencolar(t₀) ∧ res =obs proximo(t₀)}
Complejidad: O(log(#t))
Descripción: Desencola el elemento con mayor prioridad.

Tamaño(in t : ColaPrioridad(α)) → res : nat
Pre ≡ {true}
Post ≡ {res =obs #t}
Complejidad: O(1)
Descripción: Devuelve la cantidad de elementos en la cola.

Borrar(in/out t : ColaPrioridad(α), in e : α)
Pre ≡ {e ∈ t ∧ t₀ =obs t}
Post ≡ {t = borrar(e, t₀)}
Complejidad: O(#t * log(#t))
Descripción: Busca y elimina el elemento pasado por parámetro.

TAD ColaDePrioridadExtendida(α)
	extiende colaPrior(α)
	otras operaciones (exportadas)
		#∙ : colaPrior(α) → nat
		∙ ∈ ∙ : α × colaPrior(α) → bool
		borrar : α e × colaPrior(α) c → colaPrior(α) {e ∈ c}
	axiomas
		#c ≡ if vacia?(c) then 0 else 1 + #desencolar(c) fi
		x ∈ c ≡ ¬vacia?(c) ∧ₗ (x =obs proximo(c) ∨ₗ x ∈ desencolar(c))
		borrar(e, c) ≡
			if e =obs proximo(c) then
				if e ∈ desencolar(c) then borrar(e, desencolar(c))
				else desencolar(c) fi
			else encolar(proximo(c), borrar(e, desencolar(c))) fi
Fin TAD

REPRESENTACION DE LA COLA

ColaPrioridad(α) se representa con estr
	donde estr es tupla(cabeza: puntero(nodo), ultimo: puntero(nodo), elementos: nat)
	donde nodo es tupla(arr: puntero(nodo), izq: puntero(nodo), der: puntero(nodo), dato: α)

Rep: ^(estr) → boolean
Rep(e) ≡ true ⟺ MaxHeap(e.cabeza) ∧ Completo(e.cabeza) ∧ ELEMENTOS SE CONDICE

MaxHeap: puntero(nodo) → bool
MaxHeap(p) ≡
	if p =obs NULL then true
	else
		(¬(p→izq =obs NULL) ⟹ₗ p→izq→dato < p→dato) ∧
		(¬(p→der =obs NULL) ⟹ₗ p→der→dato < p→dato) ∧
		MaxHeap(p→izq) ∧
		MaxHeap(p→der)
	fi

Completo: puntero(nodo) → bool
Completo(p) ≡ ????????????????????????????????????????


Abs: ^(estr) → ColaDePrioridadExtendida(α)
(∀e : ^(estr)) Abs(e) =obs t /
	vacia?(t) =obs (e.elementos =obs 0) ∧
	¬vacia?(t) ⟹ₗ
		proximo(t) =obs e.cabeza→dato ∧
		desencolar(t) =obs ....?

Crear() → res : ColaPrioridad(α)
	res ← ⟨cabeza: NULL, ultimo: NULL, elementos: 0⟩

Tamaño(in t : ColaPrioridad(α)) → res : nat
	res = t.elementos

Encolar(in/out t : ColaPrioridad(α), in e : α) → res : itCola(α)
	var tmp : puntero(nodo) ← NULL

	tmp = ??????????????????? MEMORY ALLOCATIONNNN
	tmp→dato ← e
	tmp→izq ← NULL
	tmp→der ← NULL

	if t.ultimo == NULL then
		tmp→cabeza ← NULL
		t.cabeza ← tmp
	else
		if t.ultimo→arr→izq == t.ultimo then
			tmp→arr ← t.ultimo→arr
			t.ultimo→arr→der ← tmp
		else
			var cur : puntero(nodo) ← t.ultimo

			ESTE ES EL CASO EN EL QUE ESTAMOS A LA DERECHA Y HAY QUE
			ENCONTRAR ALGO ARRIBA DE TODO
			TERMINARRRRRRRRRRRRr----------------------------------------------
		end if
	end if

	t.ultimo = tmp
	t.elementos++

	Subir(t.ultimo)
	res ← crearIter(t, p)

Borrar(in/out t : ColaPrioridad(α), in e : α)
	IMPLEMENTARRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRR

// PRE: p != NULL
// REVISAR EL TEMA ESTE DE QUE SEA DE TIPO α SIN QUE ESTE CLARO QUE VERGA ES α
Subir(p : puntero(nodo))
	while p→arr != NULL ∧ p→arr→dato < p→dato do
		var tmp : α ← p→arr→dato
		p→arr→dato ← p→dato
		p→dato ← tmp
		p ← p→arr
	end while

// PRE: p != NULL
// REVISAR EL TEMA ESTE DE QUE SEA DE TIPO α SIN QUE ESTE CLARO QUE VERGA ES α
Bajar(p : puntero(nodo))
	while	(p→izq != NULL ∧ p→izq→dato > p→dato) ∨
			(p→der != NULL ∧ p→der→dato < p→dato) do
		if p→izq != NULL then
			var tmp : α ← p→izq→dato
			p→izq→dato ← p→dato
			p→dato ← tmp
		else
			if p→der != NULL then
				var tmp : α ← p→der→dato
				p→der→dato ← p→dato
				p→dato ← p→der→dato
			end if
		end if
	end while
