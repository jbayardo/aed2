********************************************************************************
************						 Interfaz 						************
********************************************************************************

Parametros Formales
	géneros α
	función ∙ < ∙ (in a1 : α, a2 : α) → res : bool
		Pre ≡ {true}
		Post ≡ {res =obs (a1 < a2)}
		Complejidad: O(lower(a1, a2))
		Descripción: funcion de comparación de αs

Se explica con: ColaDePrioridadExtendida(α), IteradorUnidireccional(α)
Generos: ColaPrioridad(α), itCola(α)

********************************************************************************
************					   Operaciones 						************
********************************************************************************

Crear() → res : ColaPrioridad(α)
Pre ≡ {true}
Post ≡ {res =obs vacia}
Complejidad: O(1)
Descripción: Crea una cola vacia.

Encolar(in/out t : ColaPrioridad(α), in e : α) → res : itCola(α)
Pre ≡ {¬(e ∈ t) ∧ t₀ =obs t}
Post ≡ {t =obs encolar(e, t₀) ∧ Actual(res) =obs e}
Complejidad: O(log(#t))
Descripción: Inserta un elemento en la cola y devuelve un iterador posicionado en el elemento agregado.

Desencolar(in/out t : ColaPrioridad(α)) → res : α
Pre ≡ {¬vacia?(t) ∧ t =obs t₀}
Post ≡ {t =obs desencolar(t₀) ∧ res =obs proximo(t₀)}
Complejidad: O(log(#t))
Descripción: Desencola el elemento con mayor prioridad.

Tamaño(in t : ColaPrioridad(α)) → res : nat
Pre ≡ {true}
Post ≡ {res =obs #t}
Complejidad: O(1)
Descripción: Devuelve la cantidad de elementos en la cola.

Borrar(in/out t : ColaPrioridad(α), in i : itCola(α))
Pre ≡ {t₀ =obs t}
Post ≡ {t =obs borrar(Actual(i), t₀)}
Complejidad: O(log(#t))
Descripción: Borra el elemento al que apunta el iterador.
Aliasing: Invalida el iterador??

TAD ColaDePrioridadExtendida(α)
	extiende colaPrior(α)
	otras operaciones (exportadas)
		#∙ : colaPrior(α) → nat
		∙ ∈ ∙ : α × colaPrior(α) → bool
		borrar : α e × colaPrior(α) c → colaPrior(α) {e ∈ c}
	axiomas
		#c ≡ if vacia?(c) then 0 else 1 + #desencolar(c) fi
		x ∈ c ≡ ¬vacia?(c) ∧ₗ (x =obs proximo(c) ∨ₗ x ∈ desencolar(c))
		borrar(e, c) ≡
			if e =obs proximo(c) then
				if e ∈ desencolar(c) then borrar(e, desencolar(c))
				else desencolar(c) fi
			else encolar(proximo(c), borrar(e, desencolar(c))) fi
Fin TAD

********************************************************************************
************					 Representación						************
********************************************************************************

ColaPrioridad(α) se representa con estr(α)
	donde estr(α) es tupla(
						cabeza : puntero(nodo(α)),
						ultimo : puntero(nodo(α)),
						tamaño : nat)
	donde nodo(α) es tupla(
						arr    : puntero(nodo(α)),
						izq    : puntero(nodo(α)),
						der    : puntero(nodo(α)),
						dato   : α)

Rep: ^(estr(α)) → boolean
Rep(e) ≡ true ⟺
	(e.cabeza =obs NULL ⟺ e.ultimo =obs NULL) ∧
	e.tamaño = Tamaño(e.cabeza) ∧
	InvPadres(e.cab) ∧
	No hay ciclos en el arbol ∧ₗ
	MaxHeap(e.cab) ∧
	Balanceado(e.cab) ∧
	Izquierdista(e.cab) ∧ₗ
	(¬(e.cabeza =obs NULL) ⟹ₗ
		e.cabeza→arr =obs NULL ∧
		e.ultimo ES EL ULTIMO AGREGADO)

InvPadres: puntero(nodo(α)) → bool
InvPadres(p) ≡
	if p =obs NULL then true
	else
		(¬(p→izq =obs NULL) ⟹ₗ p→izq→arr =obs p) ∧
		(¬(p→der =obs NULL) ⟹ₗ p→der→arr =obs p) ∧
		InvPadres(p→izq) ∧
		InvPadres(p→der)
	fi

MaxHeap: puntero(nodo(α)) → bool
MaxHeap(p) ≡
	if p =obs NULL then true
	else
		(¬(p→izq =obs NULL) ⟹ₗ p→izq→dato < p→dato) ∧
		(¬(p→der =obs NULL) ⟹ₗ p→der→dato < p→dato) ∧
		MaxHeap(p→izq) ∧
		MaxHeap(p→der)
	fi

Balanceado: puntero(nodo(α)) → bool
Balanceado(p) ≡
	(p =obs NULL) ∨ₗ (|Altura(p→izq) - Altura(p→der)| ≤ 1) ∧
	Balanceado(p→izq) ∧ Balanceado(p→der)

Altura: puntero(nodo(α)) → nat
Altura(p) ≡ if p =obs NULL then 0 else 1 + max(Altura(p→izq), Altura(p→der)) fi

Izquierdista: puntero(nodo(α)) → bool
Izquierdista(p) ≡
	(p =obs NULL) ∨ₗ (¬(p→der =obs NULL) ⟹ₗ ¬(p→izq =obs NULL)) ∧
	Izquierdista(p→izq) ∧ Izquierdista(p→der)

Tamaño: puntero(nodo(α)) → nat
Tamaño(p) ≡ if p =obs NULL then 0 else 1 + Tamaño(p→izq) + Tamaño(p→der) fi

Abs: ^(estr(α)) → ColaDePrioridadExtendida(α)
(∀e : ^(estr(α))) Abs(e) =obs t /
	vacia?(t) =obs (e.tam =obs 0) ∧
	¬vacia?(t) ⟹ₗ
		proximo(t) =obs e.cab→dato ∧
		(∀e : α) (((e ∈ t) ∧ ¬(e =obs proximo(t))) ⟺ (e ∈ desencolar(t)))

********************************************************************************
************					  Algoritmos						************
********************************************************************************

iCrear() → res : estr(α)
	res ← ⟨cabeza: NULL, ultimo: NULL, tamaño: 0⟩
end function

iTamaño(in t : estr(α)) → res : nat
	res ← t.tamaño
end function

/////////////////////////// VERIFICAR ENCOLAR Y DESENCOLAR

iEncolar(in/out t : estr(α), in e : α) → res : itCola(α)
	var tmp : puntero(nodo(α)) ← NULL

	tmp ← &⟨arr: NULL, izq: NULL, der: NULL, dato: e⟩

	if Tamaño(t) == 0 then
		tmp→arr ← NULL
		t.cabeza ← tmp
	else if Tamaño(t) == 1 then
		tmp→arr ← t.cabeza
		t.cabeza→izq ← tmp
	else
		if t.ultimo→arr→izq == t.ultimo then
			tmp→arr ← t.ultimo→arr
			t.ultimo→arr→der ← tmp
		else
			var cur : puntero(nodo(α)) ← t.ultimo

			while cur→arr != NULL ∧ cur→arr→izq != cur do
				cur ← cur→arr
			end while

			if cur→arr != NULL then
				cur ← cur→arr→der
			fi

			while cur→izq != NULL do
				cur ← cur→izq
			end while

			tmp→arr ← cur
			cur→izq ← tmp
		end if
	end if

	t.ultimo ← tmp
	t.tamaño++

	Subir(t.ultimo)
	res ← crearIter(t, p) ------------------- esta funcion tiene que estar
end function

iDesencolar(in/out t : estr(α)) → res : α
	res ← t.cabeza→dato

	if Tamaño(t) == 1 then
		t.ultimo ← NULL
		t.cabeza ← NULL
	else
		t.cabeza→dato ← t.ultimo→dato

		if t.ultimo→arr→izq == t.ultimo then
			var cur : puntero(nodo(α)) = t.ultimo

			while cur→arr != NULL ∧ cur→arr→der != cur do
				cur ← cur→arr
			end while

			if cur→arr != NULL then
				cur ← cur→arr→izq
			fi

			while cur→der != NULL do
				cur ← cur→der
			end while

			t.ultimo→arr→izq ← NULL
		else
			t.ultimo ← t.ultimo→arr→izq
			t.ultimo→arr→der ← NULL
		end if

		Bajar(t.cabeza)
	end if

	t.tamaño--
end function

////////////////////////////// A ESTAS 3 ULTIMAS LES FALTA LAS PRE Y POS ///////

// PRE: p != NULL
// POST: se restablecio el rep
// REVISAR EL TEMA ESTE DE QUE SEA DE TIPO α SIN QUE ESTE CLARO QUE VERGA ES α
iSubir(in/out p : puntero(nodo(α)))
	while p→arr != NULL ∧ p→arr→dato < p→dato do
		var tmp : α ← p→arr→dato
		p→arr→dato ← p→dato
		p→dato ← tmp
		p ← p→arr
	end while
end function

// PRE: p != NULL
// Post: se restablecio el rep
// REVISAR EL TEMA ESTE DE QUE SEA DE TIPO α SIN QUE ESTE CLARO QUE VERGA ES α
iBajar(in/out p : puntero(nodo(α)))
	while	(p→izq != NULL ∧ p→dato < p→izq→dato) ∨
			(p→der != NULL ∧ p→der→dato < p→dato) do
		if p→izq != NULL then
			var tmp : α ← p→izq→dato
			p→izq→dato ← p→dato
			p→dato ← tmp
		else
			if p→der != NULL then
				var tmp : α ← p→der→dato
				p→der→dato ← p→dato
				p→dato ← p→der→dato
			end if
		end if
	end while
end function

***********					Operaciones del iterador 				************

Actual(in i : itCola(α)) → res : α
Pre ≡ {HayMas?(i)}
Post ≡ {res =obs Actual(i)}
Complejidad: O(1)
Descripción: Devuelve el elemento guardado por el iterador de cola.

***********				   Representación del iterador 				************

itCola(α) se representa con it(α)
	donde it(α) es puntero(nodo)

Rep: ^(it(α)) → boolean
Rep(e) ≡ true ⟺ ¬(e =obs NULL)

Abs: ^(it(α)) → IteradorUnidireccional(α)
(∀e : ^(it(α))) Abs(e) =obs i / Siguientes(i) =obs <*e>

*********** 				Algorítmos del Iterador 				************

iActual(i : it(α)) → res : α
	res ← *i
