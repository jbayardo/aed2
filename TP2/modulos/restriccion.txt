Modulo restriccion

INTERFAZ DE LA RESTRICCION

Se explica con: Restriccion

Var(in s: string) → res: restriccion
Pre ≡ {true}
Post ≡ {res =obs <s>} poner cosas tads
Complejidad: O(1)
Descripcion: Crea una nueva restriccion

And(in r1: restriccion, in r2: restriccion) → res: restriccion
Pre ≡ {true}
Post ≡ {res =obs r1 AND r2}
Complejidad: O(1)
Descripcion: Crea una nueva restriccion que tiene que cumplir con r1 y r2

Or(in r1: restriccion, in r2: restriccion) → res: restriccion
Pre ≡ {true}
Post ≡ {res =obs r1 OR r2}
Complejidad: O(1)
Descripcion: Crea una nueva restriccion que tiene que cumplir con r1 o r2

Not(in r: restriccion) → res: restriccion
Pre ≡ {true}
Post ≡ {res =obs NOT r}
Complejidad: O(1)
Descripcion: Crea una nueva restriccion que no tiene que cumplir con r

verificar(in tags: conj(string), in r: restriccion) → res: bool
Pre ≡ {true}
Post ≡ {res =obs verificar?(tags, r)}
Complejidad: O(R)
Descripcion: Evalua si todos los strings en tags verifican la restriccion r


tipos_res es Enumerado(VAR, AND, OR, NOT)

restriccion se representa con rest, donde rest es:

tupla(
	tipo: tipos_res,
	op1: Puntero(restriccion),
	op2: Puntero(restriccion),
	valor: string
)

rep

abs


iVar(in s: string) → res: rest
	res ← (tipo: VAR, op1: NULL, op2: NULL, valor: s)

iAnd(in r1: rest, in r2: rest) → res: rest
	res ← (tipo: AND, op1: &r1, op2: &r2, valor: "")

iOr(in r1: rest, in r2: rest) → res: rest
	res ← (tipo: OR, op1: &r1, op2: &r2, valor: "")

iNot(in r: rest) → res: rest
	res ← (tipo: NOT, op1: &r, op2: NULL, valor: "")

iverificar(in tags: conj(string), in r: rest) → res: bool
	if (tipo == VAR)
		res ← pertenece?(tags, r.valor)
	endif

	if (tipo == AND)
		res ← verificar(tags, *r.op1) ∧ verificar(tags, *r.op2)
	endif

	if (tipo == OR)
		res ← verificar(tags, *r.op1) ∨ verificar(tags, *r.op2)
	endif

	if (tipo == NOT)
		res ← ¬verificar(tags, *r.op1)
	endif
/*
La complejidad de iVerificar es O(R), siendo R la cantidad de restricciones anidadas.
Esto se debe a que para verificar una restriccion vale para un conj(string), si esta no es un Var, debe verificar que valga para sus restricciones anidadas en op1 y/o op2 (depende si la restriccion es de tipo NOT o no), recursivamente, hasta llegar a un Var.
Luego, cada restriccion devuelve el resultado anidado, por lo que se pasaria por cada nodo 2 veces, ergo, O(2R), y por algebra de ordenes, esto es equivalente a O(R)
*/


