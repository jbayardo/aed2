********************************************************************************
************						 Interfaz 						************
********************************************************************************

Se explica con: Ciudad
Géneros: Ciudad

********************************************************************************
************					   Operaciones 						************
********************************************************************************

Crear(in m: Mapa) → res: Ciudad
Pre ≡ {true}
Post ≡ {res =obs Crear(m)}
Complejidad: O(#estaciones(m))
Descripcion: Crea una nueva ciudad a partir de un mapa.

Entrar(in ts: conj(tags), in e: estacion, in/out c: Ciudad)
Pre ≡ {e ∈ estaciones(c.mapa) ∧ c₀ =obs c}
Post ≡ {c =obs entrar(ts, e, c₀)}
Complejidad: O(Long(e) + S*R + Nₜₒₜₐₗ) 						VER BIEN COMO ESCRIBIR ESTA VERGA
Descripcion: Agrega un conjunto de caracteristicas nuevo a la ciudad, creando un nuevo robot.

Mover(in rur: nat, in e: estacion, in/out c: Ciudad)
Pre ≡ {u ∈ robots(c) ∧ e ∈ estaciones(c) ∧ₗ conectadas?(estacion(u, c), e, mapa(c)) ∧ c₀ =obs c}
Post ≡ {estacion(u,c) =obs e}
Complejidad: O(Long(e) + Long(estacion(u, c)) + Log(#robotsEn(estacion(u,c), c)) + Log(#robotsEn(e, c)))
Descripcion: Mueve a un robot de una estacion a otra.

Inspeccion(in e: estacion, in/out c: Ciudad)
Pre ≡ { e ∈ estaciones(c)}
Post ≡ {???}
Complejidad: O(Long(e) + Log(#robotsEn(e, c)))
Descripcion: Remueve al robot mas infractor en la estacion e de la ciudad.

ProximoRUR(in c: ciudad) → res: nat
Pre ≡ {true}
Post ≡ {res =obs ProximoRUR(c)}
Complejidad: O(1)
Descripcion: Devuelve el proximo rur disponible.

Mapa(in c: ciudad) → res: Mapa
Pre ≡ {true}
Post ≡ {res =obs Mapa(c)}
Complejidad: O(1)
Descripcion: Devuelve el mapa de la ciudad.

Robots(in c: ciudad) → res: ItVectorPointer(robot)
Pre ≡ {true}
Post ≡ {alias(res =obs Iterador Unidireccional(Puntero(robot)))}
Complejidad: O(1)
Descripcion: Devuelve un iterador de los robots que hay en la ciudad.
Aliasing: res no es modificable.

Estacion(in c: ciudad, in u: nat) → res: estacion
Pre ≡ { u ∈ robots(c)}
Post ≡ {res =obs estacion(u, c)}
Complejidad: O(1)
Descripcion: Devuelve la estacion donde esta el robot con rur u.

tags(in c: ciudad, in u: nat) → res: itConj(string)
Pre ≡ { u ∈ robots(c)}
Post ≡ {alias(res =obs CrearIt(tags(u, c)))}
Complejidad: O(1)
Descripcion: Devuelve los tags del robot con rur u.
Aliasing: res no es modificable.

#infracciones(in c: ciudad, in u: nat) → res: nat
Pre ≡ { u ∈ robots(c)}
Post ≡ {res =obs #infracciones(u, c)}
Complejidad: O(1)
Descripcion: Devuelve la cantidad de infracciones del robot con rur u.

********************************************************************************
************					 Representación						************
********************************************************************************

Ciudad se representa con ciudad,
	donde ciudad es: tupla(
						robots           : VectorPointer(robot),
						mapa             : Mapa,
						robotsEnEstacion : DiccString(colaPrioridad(robot)))
	donde robot es: tupla(
						tags                 : conj(tags),
						infracciones         : nat,
						rur                  : nat,
						infringe_restriccion : Vector(Bool),
						estacion             : string,
						mi_estacion          : itCola(robot)
	)

Rep: ^(ciudad) → boolean
Rep(e) ≡ true ⟺ ((∀ s: estacion)

Abs: ^(ciudad) → Ciudad
(∀e : ^(ciudad)) Abs(e) =obs c /
	e.robots =obs robots(c) ∧ 					VERIFICAR, ACA HAY PUNTEROS A NULL.
												HABRIA QUE CONVERTIRLO A CONJUNTO
	longitud(e.robots) =obs ProximoRUR(c) ∧
	e.mapa =obs mapa(c) ∧
	(∀u : rur)
		(u < Longitud(e.robots) ∧ₗ e.robots[u] != NULL) ⟹ₗ
			((e.robots[u].estacion =obs estacion(u, c)) ∧
			(e.robots[u].tags =obs tags(u, c)) ∧
			(e.robots[u].infracciones =obs #infracciones(u, c)))


********************************************************************************
************					  Algoritmos						************
********************************************************************************

iCrear(in m: Mapa) → res: ciudad
	var robots_en_estacion: Crear()										????????
	var it : itConj(string) ← Estaciones(m)

	while HaySiguiente(it) do
		Definir(robots_en_estacion, Siguiente(it), Crear()) ///???? Siguiente?
		Avanzar(it)
	end while

	Definir(robots_en_estacion, *it, Crear())

	res ← ⟨robots: Vacia(), mapa: m, robotsEnEstacion: robots_en_estacion ⟩
end function

iEntrar(in ts: conj(tags), in e: estacion, in/out c: ciudad)
	var rob : robot ⟨
		tags: &conj(tags),
		infracciones: 0,
		rur: ProximoRUR(ciudad),
		infringe_restriccion: Vacia(),
		estacion: e,
		mi_estacion: Encolar(obtener(robotsEnEstacion, e), rob)⟩

	var it : ItVectorPointer(Restriccion) ← Sendas(c.mapa)

	AgregarAtras(rob.infringe_restriccion, ¬Verifica?(ts, Actual(it)))

	while HaySiguiente(it) do
		Avanzar(it)
		AgregarAtras(rob.infringe_restriccion, ¬Verifica?(ts, Actual(it)))
	end while

	AgregarAtras(c.robots, &rob)
end function

iMover(in rur: nat, in e: estacion, in/out c: ciudad)
	var rob : puntero(robot) ← c.robots[rur]

	Borrar(Obtener(c.robotsEnEstacion, rob→estacion), rob→mi_estacion)

	var infringe : nat ← rob→infracciones
	var id_senda : nat ← idSenda(c.mapa, rob→estacion, e)

	if(rob→infringe_restriccion[id_senda])
		infringe ← infringe + 1
	end if

	rob→infracciones ← infringe

	rob→mi_estacion ← Encolar(obtener(c.robotsEnEstacion,  e), *rob)
end function

iInspeccion(in e: estacion, in/out c: ciudad)
	var rob : robot ← Desencolar(Obtener(c.robotsEnEstacion, e))
	c.robots[rob.rur] ← NULL
end function

iProximoRUR(in c: ciudad) → res: nat
	res ← Longitud(c.robots)
end function

iMapa(in c: ciudad) → res: Mapa
	res ← c.mapa
end function

iRobots(in c: ciudad) → res: ItVectorPointer(robot)
	res ← CrearIt(c.robots)
end function

iEstacion(in c: ciudad, in u: nat) → res: estacion
	res ← c.robots[u]→estacion
end function

itags(in c: ciudad, in u: nat) → res: itConj(string)
	res ← CrearIt(c.robots[u]→tags)
end function

i#infracciones(in c: ciudad, in u: nat) → res: nat
	res ← c.robots[u]→infracciones
end function
