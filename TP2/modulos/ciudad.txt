********************************************************************************
************						 Interfaz 						************
********************************************************************************

Se explica con: Ciudad
Géneros: Ciudad

********************************************************************************
************					   Operaciones 						************
********************************************************************************

Crear(in m : Mapa) → res : Ciudad
Pre ≡ {true}
Post ≡ {res =obs Crear(m)}
Complejidad: O(#estaciones(m) * |eₘ|)
Descripcion: Crea una nueva ciudad a partir de un mapa.

Entrar(in ts : conj(tags), in e : estacion, in/out c : Ciudad)
Pre ≡ {e ∈ estaciones(mapa(c)) ∧ c =obs c₀}
Post ≡ {c =obs entrar(ts, e, c₀)}
Complejidad: O(Long(e) + S*R + Nₜₒₜₐₗ) 						VER BIEN COMO ESCRIBIR ESTA VERGA
Descripcion: Agrega un conjunto de caracteristicas nuevo a la ciudad, creando un nuevo robot.

Mover(in rur : nat, in e : estacion, in/out c : Ciudad)
Pre ≡ {u ∈ robots(c) ∧ e ∈ estaciones(c) ∧ₗ conectadas?(estacion(u, c), e, mapa(c)) ∧ c₀ =obs c}
Post ≡ {c =obs mover(rur, e, c₀)}
Complejidad: O(Long(e) + Long(estacion(u, c)) + Log(#robotsEn(estacion(u,c), c)) + Log(#robotsEn(e, c)))
Descripcion: Mueve a un robot de una estacion a otra.

Inspeccion(in e : estacion, in/out c : Ciudad)
Pre ≡ {e ∈ estaciones(c)}
Post ≡ {c =obs inspección(e, c)}
Complejidad: O(Long(e) + Log(#robotsEn(e, c)))
Descripcion: Remueve al robot mas infractor en la estacion e de la ciudad.

ProximoRUR(in c : ciudad) → res : nat
Pre ≡ {true}
Post ≡ {res =obs ProximoRUR(c)}
Complejidad: O(1)
Descripcion: Devuelve el proximo rur disponible.

Mapa(in c : ciudad) → res : Mapa
Pre ≡ {true}
Post ≡ {res =obs Mapa(c)}
Complejidad: O(1)
Descripcion: Devuelve el mapa de la ciudad.

Robots(in c : ciudad) → res : ItVectorPointer(robot)
Pre ≡ {true}
Post ≡ {alias(res =obs Iterador Unidireccional(Puntero(robot)))}
Complejidad: O(1)
Descripcion: Devuelve un iterador de los robots que hay en la ciudad.
Aliasing: res no es modificable.

Estacion(in c : ciudad, in u : nat) → res : estacion
Pre ≡ {u ∈ robots(c)}
Post ≡ {res =obs estacion(u, c)}
Complejidad: O(1)
Descripcion: Devuelve la estacion donde esta el robot con rur u.

tags(in c : ciudad, in u : nat) → res : itConj(string)
Pre ≡ {u ∈ robots(c)}
Post ≡ {alias(res =obs CrearIt(tags(u, c)))}
Complejidad: O(1)
Descripcion: Devuelve los tags del robot con rur u.
Aliasing: res no es modificable.

#infracciones(in c: ciudad, in u: nat) → res: nat
Pre ≡ { u ∈ robots(c)}
Post ≡ {res =obs #infracciones(u, c)}
Complejidad: O(1)
Descripcion: Devuelve la cantidad de infracciones del robot con rur u.

********************************************************************************
************					 Representación						************
********************************************************************************

Ciudad se representa con ciudad,
	donde ciudad es: tupla(
						robots           : VectorPointer(robot),
						mapa             : Mapa,
						robotsEnEstacion : DiccString(colaPrioridad(robot)))
	donde robot es: tupla(
						tags                 : conj(tags),
						infracciones         : nat,
						rur                  : nat,
						infringe_restriccion : Vector(Bool),
						estacion             : string,
						mi_estacion          : itCola(robot)
	)

Rep: ^(ciudad) → boolean
Rep(e) ≡ true ⟺ ((∀ s: estacion)

Abs: ^(ciudad) → Ciudad
(∀e : ^(ciudad)) Abs(e) =obs c /
	e.robots =obs robots(c) ∧ 					VERIFICAR, ACA HAY PUNTEROS A NULL.
												HABRIA QUE CONVERTIRLO A CONJUNTO
	longitud(e.robots) =obs ProximoRUR(c) ∧
	e.mapa =obs mapa(c) ∧
	(∀u : rur)
		(u < Longitud(e.robots) ∧ₗ e.robots[u] != NULL) ⟹ₗ
			((e.robots[u].estacion =obs estacion(u, c)) ∧
			(e.robots[u].tags =obs tags(u, c)) ∧
			(e.robots[u].infracciones =obs #infracciones(u, c)))


********************************************************************************
************					  Algoritmos						************
********************************************************************************

iCrear(in m : Mapa) → res : ciudad
	var robots_en_estacion: DiccString(ColaPrioridad(robot)) ← Crear()
	var it: itConj(string) ← m.Estaciones()

	while HaySiguiente(it) do
		Definir(robots_en_estacion, Siguiente(it), Crear()) ///???? Siguiente?
		Avanzar(it)
	end while

	Definir(robots_en_estacion, *it, Crear())

	res ← ⟨robots: Vacia(), mapa: m, robotsEnEstacion: robots_en_estacion ⟩
end function

Explicacion de la complejidad.
Recorrer todas las estaciones en el mapa es O(E).
Definir cada entrada en robots_en_estacion es O(|eₘ|), siendo eₘ el nombre de estacion mas largo, y hay que hacerlo E veces.
Por esto, la complejidad es O(|eₘ| * E)

iEntrar(in ts : conj(tags), in e : estacion, in/out c : ciudad)
	var rob : robot ⟨
		tags: &conj(tags),
		infracciones: 0,
		rur: ProximoRUR(ciudad),
		infringe_restriccion: Vacia(),
		estacion: e,
		mi_estacion: Encolar(obtener(robotsEnEstacion, e), rob)⟩

	var it : ItVectorPointer(Restriccion) ← Sendas(c.mapa)

	AgregarAtras(rob.infringe_restriccion, ¬Verifica?(ts, Actual(it)))

	while HaySiguiente(it) do
		Avanzar(it)
		AgregarAtras(rob.infringe_restriccion, ¬Verifica?(ts, Actual(it)))
	end while

	AgregarAtras(c.robots, &rob)
end function

Explicacion de la complejidad.
La operacion obtener(robotsEnEstacion, e) tiene complejidad O(|e|).
La operacion Encolar de cola de prioridad es O(Log de la cantidad de elementos de la cola).
Como se evaluan todas las sendas para saber si un robot infringe o no, el recorrido lineal del iterador es O(S), siendo S la cantidad de sendas que hay en el mapa.
Evaluar si un robot infringe o no cada senda (Verifica?) es O(R).
Finalmente, agregar un robot a robots de la ciudad es O(N) en el peor caso, siendo N la cantidad de robots en la ciudad, como esta explicado en agregar atras de vector. Este O(N) por algebra de ordenes acota superiormente al costo logaritmico de encolar.
Finalmente, la complejidad queda en |e| + S*R + Nₜₒₜₐₗ

iMover(in rur : nat, in e : estacion, in/out c : ciudad)
	var rob : puntero(robot) ← c.robots[rur]

	Borrar(Obtener(c.robotsEnEstacion, rob→estacion), rob→mi_estacion)

	var infringe : nat ← rob→infracciones
	var id_senda : nat ← idSenda(c.mapa, rob→estacion, e)

	if(rob→infringe_restriccion[id_senda])
		infringe ← infringe + 1
	end if

	rob→infracciones ← infringe

	rob→mi_estacion ← Encolar(obtener(c.robotsEnEstacion,  e), *rob)
end function

La complejidad de Obtener es O(|e1|), siendo e1 rob→estacion.
Borrar de la cola de prioridad teniendo el iterador al elemento es O(Log(#cola)), siendo #cola la cantidad de elementos de la cola.
Todo el calculo de si infringe o no es O(1) porque ya esta precalculado.
Luego, insertarlo en otra cola es O(|e|) para encontrarla en el diccionario y O(Log(#cola)) para insertarlo.
Esto da como resultado O(|e1| + |e| + Log(#cola1) + Log(#cola2))

iInspeccion(in e: estacion, in/out c: ciudad)
	var rob : robot ← Desencolar(Obtener(c.robotsEnEstacion, e))
	c.robots[rob.rur] ← NULL
end function

iProximoRUR(in c: ciudad) → res: nat
	res ← Longitud(c.robots)
end function

iMapa(in c: ciudad) → res: Mapa
	res ← c.mapa
end function

iRobots(in c: ciudad) → res: ItVectorPointer(robot)
	res ← CrearIt(c.robots)
end function

iEstacion(in c: ciudad, in u: nat) → res: estacion
	res ← c.robots[u]→estacion
end function

itags(in c: ciudad, in u: nat) → res: itConj(string)
	res ← CrearIt(c.robots[u]→tags)
end function

i#infracciones(in c: ciudad, in u: nat) → res: nat
	res ← c.robots[u]→infracciones
end function
