********************************************************************************
************						 Interfaz 						************
********************************************************************************

Se explica con: Ciudad
Géneros: Ciudad

********************************************************************************
************					   Operaciones 						************
********************************************************************************

Crear(in m: Mapa) → res: Ciudad
Pre ≡ {true}
Post ≡ {res =obs Crear(m)}
Complejidad: O(#m.Estaciones())
Descripcion: Crea una nueva ciudad a partir de un mapa.

Entrar(in ts: conj(tags), in e: estacion, in/out c: Ciudad)
Pre ≡ {e ∈ estaciones(c.mapa)}
Post ≡ {c.robots[ProximoRUR-1].tags =obs ts }
Complejidad: O(|e| + S*R + Nₜₒₜₐₗ)
Descripcion: Agrega un conjunto de caracteristicas nuevo a la ciudad, creando un nuevo robot.

Mover(in rur: nat, in e: estacion, in/out c: Ciudad)
Pre ≡ {u ∈ robots(c) ∧ e ∈ estaciones(c) ∧ₗ conectadas?(estacion(u, c), e, mapa(c))}
Post ≡ {estacion(u,c) =obs e}
Complejidad: O(|e| + |estacion(u,c)| + Log(Nₑ) + Log)  //Ver bien! :D
Descripcion: Mueve a un robot de una estacion a otra.

Inspeccion(in e: estacion, in/out c: Ciudad)
Pre ≡ { e ∈ estaciones(c)}
Post ≡ {???}
Complejidad: O(|e| + Log(Nₑ))
Descripcion: Remueve al robot mas infractor en la estacion e de la ciudad.

ProximoRUR(in c: ciudad) → res: nat
Pre ≡ {true}
Post ≡ {res =obs ProximoRUR(c)}
Complejidad: O(1)
Descripcion: Devuelve el proximo rur disponible.

Mapa(in c: ciudad) → res: Mapa
Pre ≡ {true}
Post ≡ {res =obs Mapa(c)}
Complejidad: O(1)
Descripcion: Devuelve el mapa de la ciudad.

Robots(in c: ciudad) → res: ItVectorPointer(robot)
Pre ≡ {true}
Post ≡ {alias(res =obs Iterador Unidireccional(Puntero(robot)))}
Complejidad: O(1)
Descripcion: Devuelve un iterador de los robots que hay en la ciudad.
Aliasing: res no es modificable.

Estacion(in c: ciudad, in u: nat) → res: estacion
Pre ≡ { u ∈ robots(c)}
Post ≡ {res =obs Estacion(u, c)}
Complejidad: O(1)
Descripcion: Devuelve la estacion donde esta el robot con rur u.

tags(in c: ciudad, in u: nat) → res: itConj(string)
Pre ≡ { u ∈ robots(c)}
Post ≡ {alias(res =obs CrearIt(tags(u, c)))}
Complejidad: O(1)
Descripcion: Devuelve los tags del robot con rur u.
Aliasing: res no es modificable.

#infracciones(in c: ciudad, in u: nat) → res: nat
Pre ≡ { u ∈ robots(c)}
Post ≡ {res =obs #infracciones(u, c)}
Complejidad: O(1)
Descripcion: Devuelve la cantidad de infracciones del robot con rur u.

********************************************************************************
************					 Representación						************
********************************************************************************

Ciudad se representa con city,
	donde city es: tupla(
						robots: VectorPointer(robot),
						mapa: Mapa,
						robotsEnEstacion: DiccString(colaPrioridad(robot)),
						)

	robot es: tupla(
					tags: Puntero(conj(tags)),
					infracciones: nat,
					rur: nat,
					infringe_restriccion: Vector(Bool),
					estacion: string,
					mi_estacion: itCola(robot)
	)

Rep: ^(city) → boolean
Rep(e) ≡ true ⟺ ((∀ s: estacion) 

Abs: ^(city) → Ciudad
(∀e : ^(city)) Abs(e) =obs c / e.robots =obs robots(c) 
						∧ longitud(e.robots) =obs ProximoRUR(c)
						∧ e.mapa =obs Mapa(c)
						∧ ((∀u: rur) (u < Longitud(e.robots) ∧ₗ e.robots[u] != NULL ∧ₗ 
						(e.robots[u].estacion =obs Estacion(u,c) ∧ (*e.robots[u].tags =obs tags(u,c))
						∧ (e.robots[u].infracciones =obs #infracciones(u,c))))


********************************************************************************
************					  Algoritmos						************
********************************************************************************


iCrear(in m: Mapa) → res: city
	robots_en_estacion: Crear()
	it: itConj(string)
	it ← m.Estaciones()

	while HaySiguiente(it) do
		Definir(robots_en_estacion, Siguiente(it), Crear()) ///???? Siguiente?
		Avanzar(it)
	end while

	Definir(robots_en_estacion, *it, Crear())

	res ← ⟨robots: Vacia(), mapa: m, robotsEnEstacion: robots_en_estacion ⟩


iEntrar(in ts: conj(tags), in e: estacion, in/out c: city)
	rob: robot

	rob ← ⟨tags: &conj(tags), infracciones: 0, rur: ProximoRUR(city), infringe_restriccion: Vacia(), estacion: e, mi_estacion: Encolar(obtener(robotsEnEstacion, e), rob)⟩

	it: ItVectorPointer(Restriccion)
	it ← Sendas(c.mapa)

	AgregarAtras(rob.infringe_restriccion, ¬Verifica?(ts, Actual(it)))

	while HaySiguiente(it) do
		Avanzar(it)
		AgregarAtras(rob.infringe_restriccion, ¬Verifica?(ts, Actual(it)))
	end while

	AgregarAtras(c.robots, &rob)


iMover(in rur: nat, in e: estacion, in/out c: city)
	rob: Puntero(robot)

	rob ← c.robots[rur]

	Borrar(Obtener(c.robotsEnEstacion, rob→estacion), rob→mi_estacion)

	infringe: nat

	infringe ← rob→infracciones

	id_senda: nat

	id_senda ← idSenda(c.mapa, rob→estacion, e)

	if(rob→infringe_restriccion[id_senda])
		infringe ← infringe + 1
	end if

	rob→infracciones ← infringe

	rob→mi_estacion ← Encolar(obtener(c.robotsEnEstacion,  e), *rob)

iInspeccion(in e: estacion, in/out c: city)
	rob: robot
	rob ← Desencolar(Obtener(c.robotsEnEstacion, e))
	c.robots[rob.rur] ← NULL

iProximoRUR(in c: city) → res: nat
	res ← Longitud(c.robots)

iMapa(in c: city) → res: Mapa
	res ← c.mapa

iRobots(in c: city) → res: ItVectorPointer(robot)
	res ← CrearIt(c.robots)

iEstacion(in c: city, in u: nat) → res: estacion
	res ← c.robots[u]→estacion

itags(in c: city, in u: nat) → res: itConj(string)
	res ← CrearIt(c.robots[u]→tags)

i#infracciones(in c: city, in u: nat) → res: nat
	res ← c.robots[u]→infracciones



