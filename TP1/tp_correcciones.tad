TAD caracteristica ES string

TAD Restriccion
  generos restriccion
  exporta AND, OR, NOT, VAR, cumple, FALSE, TRUE
  igualdad observacional
    (∀r₁, r₂ : restriccion) (r₁ =obs r₂ ⟺
      (∀c : conj(caracteristica)) (cumple(c, r₁) =obs cumple(c, r₂)))
  observadores basicos
    cumple: conj(caracteristica) × restriccion → bool
  generadores
    AND: restriccion × restriccion → restriccion
    OR: restriccion × restriccion → restriccion
    NOT: restriccion → restriccion
    VAR: caracteristica → restriccion
  otras operaciones
    TRUE: → restriccion
    FALSE: → restriccion
  axiomas (∀cs : conj(caracteristica)) (∀c1, c2 : restriccion) (∀c : caracteristica)
    cumple(cs, VAR(c)) ≡ c ∈ cs
    cumple(cs, NOT(c1)) ≡ ¬(cumple(cs, c1))
    cumple(cs, AND(c1, c2)) ≡ cumple(cs, c1) ∧ cumple(cs, c2)
    cumple(cs, OR(c1, c2)) ≡ cumple(cs, c1) ∨ cumple(cs, c2)

    TRUE ≡ OR(VAR("dummy"), NOT(VAR("dummy")))

    FALSE ≡ AND(VAR("dummy"), NOT(VAR("dummy")))
Fin TAD

TAD estacion ES string
TAD conexion ES ⟨estacion, restriccion⟩
TAD conexiones ES conj(conexion)

TAD Mapa
  generos mapa
  exporta estaciones, conexiones, nuevo, crearEst, conectar,
          esBloqueante, conectadas, camino
  igualdad observacional
    (∀m₁, m₂ : mapa) (m₁ =obs m₂ ⟺
      estaciones(m₁) =obs estaciones(m₂) ∧ₗ
      (∀e ∈ estaciones(m₁)) (conexiones(m₁, e) =obs conexiones(m₂, e)))
  observadores basicos
    estaciones : mapa → conj(estacion)
    conexiones : mapa m × estacion e → conj(conexion) {e ∈ estaciones(m)}
  generadores
    nuevo    : → mapa
    crearEst : mapa m × estacion a → mapa {¬(a ∈ estaciones(m))}
    conectar : mapa m × estacion a × estacion b × restriccion → mapa
               {a, b ∈ estaciones(m) ∧ₗ ¬conectadas(m, a, b)}
  otras operaciones
    esBloqueante  : mapa m × conj(caracteristica) × estacion e → bool {e ∈ estaciones(m)}
    esBloqueante' : conj(conexion) × conj(caracteristica) → bool
    conectadas    : mapa m × estacion a × estacion b → bool {a, b ∈ estaciones(m)}
    conectadas'   : estacion × conj(conexion) → bool
    camino        : mapa m × estacion a × estacion b → restriccion
      {a, b ∈ estaciones(m) ∧ conectadas(m, a, b)}
    camino'       : estacion e × conj(conexion) xs → restriccion
      {(∃x ∈ xs) π₁(x) =obs e}
  axiomas (∀m : mapa) (∀e, a, b : estacion) (∀r : restriccion) (∀cs : conj(caracteristica)) (∀xs : conj(conexion))
    conexiones(crearEst(m, e), k) ≡ ϕ
    conexiones(conectar(m, a, b, r), e) ≡
      (if e =obs a then ⟨b, r⟩
      else if e =obs b then ⟨a, r⟩ else ϕ fi
      fi) ∪ conexiones(m, e)

    estaciones(nuevo) ≡ ϕ
    estaciones(crearEst(m, e)) ≡ { e } ∪ estaciones(m)
    estaciones(conectar(m, a, b)) ≡ estaciones(m)

    esBloqueante(m, cs, e) ≡
      if ϕ?(conexiones(m, e)) then False
      else esBloqueante'(conexiones(m, e), cs) fi

    esBloqueante'(xs, cs) ≡
      if ϕ?(xs) then True
      else ¬(cumple(r, π₂(dameUno(xs)))) ∧ₗ esBloqueante'(sinUno(xs), cs) fi

    conectadas(m, a, b) ≡ conectadas'(b, conexiones(m, a))

    conectadas'(a, xs) ≡
      if ϕ?(xs) then False
      else (π₁(dameUno(xs)) =obs a) ∨ₗ conectadas'(a, sinUno(xs)) fi

    camino(m, a, b) ≡ camino'(b, conexiones(m, a))

    camino'(a, xs) ≡
      if π₁(dameUno(xs)) =obs a then π₂(dameUno(xs))
      else caminos'(a, sinUno(xs)) fi
Fin TAD

TAD rur ES nat
TAD robot ES ⟨rur, conj(caracteristica)⟩

TAD Ciudad
  generos ciudad
  exporta
  igualdad observacional
  (∀c₁, c₂: ciudad) (c₁ =obs c₂ ⟺
    mapeo(c₁) =obs mapeo(c₂) ∧ robots(c₁) =obs robots(c₂) ∧ₗ
    ((∀e ∈ estaciones(mapeo(c))) (#inspecciones(c₁) =obs #inspecciones(c₂))) ∧ₗ
    ((∀r ∈ robots(c₁)) (
      infracciones(c₁, π₁(r)) =obs infracciones(c₂, π₁(r)) ∧
      posicion(c₁, π₁(r)) =obs posicion(c₂, π₁(r))))
  observadores basicos
    mapeo: ciudad → mapa
    robots: ciudad → conj(robot)
    posicion: ciudad c × rur i → estacion {(∃r ∈ robots(c)) π₁(r) =obs i}
    infracciones: ciudad c × rur i → nat {(∃r ∈ robots(c)) π₁(r) =obs i}
    #inspecciones: ciudad c × estacion e → nat {e ∈ estaciones(mapeo(c))}
  generadores
    nueva: mapa → ciudad
    agregar: ciudad c × conj(caracteristica) cs × estacion e → ciudad
      {¬ϕ?(cs) ∧ e ∈ estaciones(mapeo(c)) ∧ₗ ¬esBloqueante(mapeo(c), cs, e)}
    mover: ciudad c × rur i × estacion e → ciudad
      {e ∈ estaciones(mapeo(c)) ∧ (∃r ∈ robots(c)) π₁(r) =obs i ∧ₗ
      conectadas(mapeo(c), posicion(c, i), e)}
    inspeccion: ciudad c × estacion e → ciudad {e ∈ estaciones(mapeo(c))}
  otras operaciones
    id: ciudad c → rur {¬ϕ?(robots(c)}

    masInfracciones: ciudad c × estacion e → conj(robot) {e ∈ estaciones(mapeo(c))}
    robotsEnEstacion: ciudad c × conj(robot) cr × estacion → conj(robot) {cr ⊆ robots(c)}
    maxInfractor: ciudad c x conj(robot) cr x robot r -> robot 
                {r ∈ robots(c) ∧ cr ⊆ robots(c)}

    caracteristicaMasInfractora: ciudad c → caracteristica
      {(∃r ∈ robots(c)) infracciones(π₁(r)) > 0 }

    maxCarInfractora: conj(caracteristica) x caracteristica x dicc(caracteristica, nat) -> caracteristica

    infraccionesXCaracteristica: ciudad c x conj(robot) cr-> dicc(caracteristica, nat)
                                  {cr ⊆ robots(c)}

    agregarCarInfDicc: conj(caracteristica) x nat x dicc(caracteristica, nat) -> dicc(caracteristica, nat)

    prevVal: caracteristica k x dicc(caracteristica, nat) d -> nat

  axiomas (∀m : mapa) (∀c : ciudad) (∀cs : conj(caracteristicas)) (∀e, e' : estacion) (∀i : rur)
    mapeo(nueva(m)) ≡ m
    mapeo(agregar(c, cc, e)) ≡ mapeo(c)
    mapeo(mover(c, r, e)) ≡ mapeo(c)
    mapeo(inspeccion(c, e)) ≡ mapeo(c)

    robots(nueva) ≡ ϕ
    robots(agregar(c, cc, e)) ≡ Ag(⟨id(c) + 1, cc⟩, robots(c))
    robots(mover(c, r, e)) ≡ robots(c)
    robots(inspeccion(c, e)) ≡ robots(c) - masInfracciones(c, e)

    posicion(agregar(c, cc, e), r) ≡
      if id(c) + 1 =obs r then e
      else posicion(c, r) fi
    posicion(mover(c, i, e), r) ≡
      if i =obs r then e
      else posicion(c, r) fi
    posicion(inspeccion(c, e), r) ≡ posicion(c, r)

    infracciones(agregar(c, cc, e), r) ≡
      if id(c) + 1 =obs r then 0
      else infracciones(c) fi

    infracciones(inspeccion(c, e), r) ≡ infracciones(c, r)

    infracciones(mover(c, i, e), r) ≡
      if r =obs i then
        infracciones(c, r) + β(¬cumple(camino(mapeo(c), posicion(c, r), e)))
      else infracciones(c, r) fi

    -- Ver si estuvo bien poner esto como observador
    -- El argumento es que no hay otra forma de contar la cantidad de inspecciones
    -- que no sea haciendo pattern matching, por lo que no ponerlo como obs
    -- haría que la operación pudiera ver más que los observadores.
    #inspecciones(nueva, e) ≡ 0
    #inspecciones(agregar(c, cc, e'), e) ≡ #inspecciones(c)
    #inspecciones(mover(c, i, e'), e) ≡ #inspecciones(c)
    #inspecciones(inspeccion(c, e'), e) ≡ β(e' =obs e) + #inspecciones(c, e)

    -- Ver si esto no debería ser observador
    -- El argumento es que no hay otra forma de contar los robots agregados que
    -- no sea hacer pattern matching.
    id(nueva) ≡ 0
    id(agregar(c, cc, e)) ≡ 1 + id(c)
    id(mover(c, i, e)) ≡ id(c)
    id(inspeccion(c, e)) ≡ id(c)

    masInfracciones(c, e) ≡
      if(ϕ?(robotsEnEstacion(c, robots(c), e))) then ϕ
      else
        if ϕ?(robotsEnEstacion(c, robots(c), e)) then ϕ
        else
          if(infracciones(c, π₁(maxInfractor(c,
                          sinUno(robotsEnEstacion(c, robots(c), e)),
                          dameUno(robotsEnEstacion(c, robots(c), e))))
                          ) > 0) then
          Ag(maxInfractor(c, sinUno(robotsEnEstacion(c, robots(c), e)),
                          dameUno(robotsEnEstacion(c, robots(c), e))), ϕ)
          else ϕ fi
        fi
      fi

    maxInfractor(c, cr, r) ≡
      if (ϕ?(cr)) then r
      else
        if(infracciones(c, π₁(dameUno(cr))) > infracciones(c, π₁(r))) then
          maxInfractor(c, sinUno(cr), dameUno(cr))
        else maxInfractor(c, sinUno(cr), r) fi
      fi

    robotsEnEstacion(c, cr, e) ≡
      if ϕ?(cr) then ϕ
      else
        if posicion(c, π₁(dameUno(cr))) =obs e then
          Ag(dameUno(cr), robotsEnEstacion(c, sinUno(cr), e))
        else robotsEnEstacion(c, sinUno(cr), e) fi
      fi

    caracteristicaMasInfractora(c) ≡ maxCarInfractora(
                      sinUno(claves(infraccionesXCaracteristica(c, robots(c)))),
                      dameUno(claves(infraccionesXCaracteristica(c, robots(c)))),
                      infraccionesXCaracteristica(c, robots(c))
                    )


    maxCarInfractora(cc, car, d) ≡ if (ϕ?(cc)) then car
                     else
                        if(obtener(dameUno(cc), d) > obtener(car, d)) then
                          maxCarInfractora(sinUno(cc), dameUno(cc), d)
                        else
                          maxCarInfractora(sinUno(cc), car, d)
                        fi
                      fi

    infraccionesXCaracteristica(c,r) ≡ if (ϕ?(r)) then vacio
                      else agregarCarInfDicc(
                          π₂(dameUno(r)),
                          infracciones(c, π₁(dameUno(r))),
                          infraccionesXCaracteristica(c, sinUno(r)
                      ) fi

    agregarCarInfDicc(cc, i, d) ≡ if (ϕ?(cc)) then d
                    else definir(dameUno(cc), i + prevVal(dameUno(cc), d),
                        agregarCarInfDicc(sinUno(cc), i, d))
                    fi

    prevVal(k, d) ≡ if (def?(k, d)) then obtener(k, d) else 0 fi


Fin TAD
