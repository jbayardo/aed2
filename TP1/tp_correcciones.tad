TAD caracteristica ES string

TAD Restriccion
  generos restriccion
  exporta AND, OR, NOT, VAR, cumple, FALSE, TRUE
  igualdad observacional
    (∀ r₁, r₂ : restriccion) (r₁ =obs r₂ ↔
      (∀ c : conj(caracteristica)) (cumple(c, r₁) =obs cumple(c, r₂)))
  observadores basicos
    cumple: conj(caracteristica) × restriccion → bool
  generadores
    AND: restriccion × restriccion → restriccion
    OR: restriccion × restriccion → restriccion
    NOT: restriccion → restriccion
    VAR: caracteristica → restriccion
  otras operaciones
    TRUE: → restriccion
    FALSE: → restriccion
  axiomas
    cumple(cs, VAR(c)) ≡ c ∈ cs
    cumple(cs, NOT(c)) ≡ ¬(cumple(cs, c))
    cumple(cs, AND(c1, c2)) ≡ cumple(cs, c1) ∧ cumple(cs, c2)
    cumple(cs, OR(c1, c2)) ≡ cumple(cs, c1) ∨ cumple(cs, c2)

    TRUE ≡ OR(VAR("dummy"), NOT(VAR("dummy")))

    FALSE ≡ AND(VAR("dummy"), NOT(VAR("dummy")))
Fin TAD

TAD estacion ES string
TAD conexion ES ⟨estacion, restriccion⟩
TAD conexiones ES conj(conexion)

TAD Mapa
  generos mapa
  exporta estaciones, conexiones, nuevo, crearEst, conectar,
          esBloqueante, conectadas, camino
  igualdad observacional
    (∀ m₁, m₂ : mapa) (m₁ =obs m₂ ↔
      estaciones(m₁) =obs estaciones(m₂) ∧ₗ
      (∀ e ∈ estaciones(m₁)) (conexiones(m₁, e) =obs conexiones(m₂, e)))
  observadores basicos
    estaciones : mapa → conj(estacion)
    conexiones : mapa m × estacion e → conj(conexion) {e ∈ estaciones(m)}
  generadores
    nuevo    : → mapa
    crearEst : mapa m × estacion a → mapa {a ∉ estaciones(m)}
    conectar : mapa m × estacion a × estacion b × restriccion → mapa
               {a, b ∈ estaciones(m) ∧ₗ ¬conectadas(m, a, b)}
  otras operaciones
    esBloqueante  : mapa m × conj(caracteristica) × estacion e → bool {e ∈ estaciones(m)}
    esBloqueante' : conj(conexion) × conj(caracteristica) → bool

    conectadas    : mapa m × estacion a × estacion b → bool {a, b ∈ estaciones(m)}
    conectadas'   : estacion × conj(conexion) → bool

    camino        : mapa m × estacion a × estacion b → restriccion
                    {a, b ∈ estaciones(m) ∧ conectadas(m, a, b)}
    camino'       : estacion × conj(conexion) → restriccion
  axiomas
    conexiones(crearEst(m, e), k) ≡ ϕ
    conexiones(conectar(m, a, b, r), e) ≡
      (if e ≡ a then
        ⟨b, r⟩
      else
        if e ≡ b then
          ⟨a, r⟩
        else
          ϕ
        fi
      fi) ∪ conexiones(m, e)

    estaciones(nuevo) ≡ ϕ
    estaciones(crearEst(m, e)) ≡ { e } ∪ estaciones(m)
    estaciones(conectar(m, a, b)) ≡ estaciones(m)

    esBloqueante(m, r, e) ≡
      if ϕ?(conexiones(m, e)) then
        False
      else
        esBloqueante'(conexiones(m, e), r)
      fi

    esBloqueante'(c, r) ≡
      if ϕ?(c) then
        True
      else
        ¬(cumple(r, π₂(dameUno(c)))) ∧ₗ esBloqueante'(sinUno(c), r)
      fi

    conectadas(m, a, b) ≡ conectadas'(b, conexiones(m, a))

    conectadas'(a, c) ≡
      if ϕ?(c) then
        False
      else
        π₁(dameUno(c)) ≡ a) ∨ₗ conectadas'(a, sinUno(c))
      fi

    camino(m, a, b) ≡ camino'(b, conexiones(m, a))

    camino'(a, c) ≡
      if π₁(dameUno(c)) ≡ a then
          π₂(dameUno(c))
      else
          caminos'(a, sinUno(c))
      fi
Fin TAD

TAD rur ES nat
TAD robot ES ⟨rur, conj(caracteristica)⟩

TAD Ciudad
  generos ciudad
  exporta
  igualdad observacional
  (∀ c₁, c₂: Ciudad) (c₁ =obs c₂ ↔
    mapeo(c₁) =obs mapeo(c₂) ∧ robots(c₁) =obs robots(c₂)
    ∧ₗ ((∀ r₁, r₂ : robot) r₁ ∈ robots(c₁) ∧ r₂ ∈ robots(c₁)
                              ∧ₗ (infracciones(c₁, π₁(r₁)) = infracciones(c₂, π₂(r₂))
                                  ∧ posicion(c₁, π₁(r₁)) = posicion(c₂, π₂(r₂))) 
          )
  )


  observadores basicos
    mapeo: ciudad → mapa
    robots: ciudad → conj(robot)    
    posicion: ciudad c × rur i → estacion {(∃r ∈ robots(c)) π₁(r) =obs i}
    infracciones: ciudad c × rur i → nat {(∃r ∈ robots(c)) π₁(r) =obs i}

  generadores
    nueva: mapa → ciudad
    agregar: ciudad c × conj(caracteristica) cs × estacion e → ciudad
      {¬(cs =obs ϕ) ∧ₗ e ∈ estaciones(mapeo(c)) ∧ₗ ¬esBloqueante(mapeo(c), cs, e)}
    mover: ciudad c × rur i × estacion e → ciudad
      {e ∈ estaciones(mapeo(c)) ∧ (∃r ∈ robots(c)) π₁(r) =obs i ∧ EXISTE UNA CONEXION}
    inspeccion: ciudad c × estacion e → ciudad {e ∈ estaciones(mapeo(c))}
  otras operaciones
    id: ciudad c → rur {¬(robots(c) =obs ϕ)}
    masInfracciones: ciudad c × estacion e → conj(robot) {e ∈ estaciones(mapeo(c)) ∧ TODO Q haya algun robot}

    -- RTP 1 -------------------------------------------------------------------
    huboInspeccion: ciudad → bool
    inspecciones: ciudad c × estacion e → nat {e ∈ estaciones(mapeo(c))}

    caracteristicaMasInfractora: ciudad c -> caracteristica
    maxCarInfractora: conj(caracteristica) cc x caracteristica car x dicc(caracteristica, nat) d -> caracteristica
    infraccionesXCaracteristica: ciudad c x conj(robot) r -> dicc(caracteristica, nat)
    agregarCarInfDicc: conj(caracteristica) cc x nat i x dicc(caracteristica, nat) d-> dicc(caracteristica, nat)
    prevVal: caracteristica k x dicc(caracteristica, nat) d -> nat

  axiomas
    mapeo(nueva(m)) ≡ m
    mapeo(agregar(c, cs, e)) ≡ mapeo(c)
    mapeo(mover(c, r, e)) ≡ mapeo(c)
    mapeo(inspeccion(c, e)) ≡ mapeo(c)

    robots(nueva) ≡ ϕ
    robots(agregar(c, cs, e)) ≡ Ag(⟨id(c) + 1, cs⟩, robots(c))
    robots(mover(c, r, e)) ≡ robots(c)
    robots(inspeccion(c, e)) ≡ robots(c) - masInfracciones(c, e)

    infracciones(agregar(c, cs, e), r) ≡
      if id(c) + 1 ≡ r then
        0
      else
        infracciones(c)
    infracciones(mover(c, i, e), r) ≡
      if r ≡ i then
        if cumple(camino(mapeo(c), posicion(c, r), e)) then
          infracciones(c, r)
        else
          1 + infracciones(c, r)
      else
        infracciones(c, r)
    infracciones(inspeccion(c, e), r) ≡ infracciones(c, r)

    posicion(agregar(c, cs, e), r) ≡
      if id(c) + 1 ≡ r then
        e
      else
        posicion(c, r)
    posicion(mover(c, i, e), r) ≡
      if i ≡ r then
        e
      else
        posicion(c, r)
    posicion(inspeccion(c, e), r) ≡ posicion(c, r)

    id(nueva) ≡ 0
    id(agregar(c, cs, e)) ≡ 1 + id(c)
    id(mover(c, i, e)) ≡ id(c)
    id(inspeccion(c, e)) ≡ id(c)

    masInfracciones(c, e) ≡
      if(ϕ?(robotsEnEstacion(c, robots(c), e))) then
        ϕ
      else
        if(infracciones(c, π₁(maxInfractor(c,
                        sinUno(robotsEnEstacion(c, robots(c), e)),
                        dameUno(robotsEnEstacion(c, robots(c), e))))
                        ) > 0) then
        Ag(maxInfractor(c, sinUno(robotsEnEstacion(c, robots(c), e)),
                        dameUno(robotsEnEstacion(c, robots(c), e))), ϕ)
        else ϕ
      fi

    maxInfractor: ciudad c x conj(robot) cr x robot r -> robot r
    maxInfractor(c, cr, r) ≡
      if (ϕ?(cr)) then
        r
      else
        if(infracciones(c, π₁(dameUno(cr))) > r)) then
          maxInfractor(c, sinUno(cr), dameUno(cr))
        else
          maxInfractor(c, sinUno(cr), r)
        fi
      fi


    robotsEnEstacion: ciudad c x conj(robot) r x estacion e -> conj(robot)
    robotsEnEstacion(c, r, e) ≡
      if (ϕ?(r)) then
        ϕ
      else
          if(posicion(c, (π₁(dameUno(r))) = e) then
            Ag(dameUno(r), robotsEnEstacion(c, sinUno(r), e))
          else
            robotsEnEstacion(c, sinUno(r), e)
          fi
      fi

---- RTP 1 ---------------------------------------------------------------------
    huboInspeccion(nueva) ≡ false
    huboInspeccion(agregar(c, cs, e)) ≡ huboInspeccion(c)
    huboInspeccion(mover(c, i, e)) ≡ huboInspeccion(c)
    huboInspeccion(inspeccion(c, e)) ≡ true

    inspecciones(nueva, p) ≡ 0
    inspecciones(agregar(c, cs, e), p) ≡ inspecciones(c)
    inspecciones(mover(c, i, e), p) ≡ inspecciones(c)
    inspecciones(inspeccion(c, e), p) ≡ β(e ≡ p) + inspecciones(c, p)

    caracteristicaMasInfractora(c) ≡ if (ϕ?(claves(infraccionesXCaracteristica(c, robots(c))))) then "dummy"
                else maxCarInfractora(
                      sinUno(claves(infraccionesXCaracteristica(c, robots(c)))),
                      dameUno(claves(infraccionesXCaracteristica(c, robots(c)))),
                      infraccionesXCaracteristica(c, robots(c))
                    )
                fi

    maxCarInfractora(cc, car, d) ≡ if (ϕ?(cc)) then car 
                     else 
                        if(obtener(dameUno(cc), d) > obtener(car, d)) then
                          maxCarInfractora(sinUno(cc), dameUno(cc), d)
                        else 
                          maxCarInfractora(sinUno(cc), car, d)
                        fi
                      fi



    infraccionesXCaracteristica(c,r) ≡ if (ϕ?(r)) then vacio
                      else agregarCarInfDicc(
                          π₂(dameUno(r)), 
                          infracciones(c, π₁(dameUno(r))), 
                          infraccionesXCaracteristica(c, sinUno(r)
                      ) fi

    agregarCarInfDicc(cc, i, d) ≡ if (ϕ?(cc)) then d
                    else definir(dameUno(cc), i + prevVal(dameUno(cc), d),
                        agregarCarInfDicc(sinUno(cc), i, d))
                    fi

    prevVal(k, d) ≡ if (def?(k, d)) then obtener(k, d) else 0 fi
Fin TAD
