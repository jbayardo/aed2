<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<meta charset="UTF-8">
<html>
<head>
<title>/home/izikiel/Algo2/AlgoII/TP2/modulos/ciudad.txt</title>
<style>
.highlight .hll { background-color: #ffffcc }
.highlight .c { color: #408080; font-style: italic } /* Comment */
.highlight .err { border: 1px solid #FF0000 } /* Error */
.highlight .k { color: #008000; font-weight: bold } /* Keyword */
.highlight .o { color: #666666 } /* Operator */
.highlight .cm { color: #408080; font-style: italic } /* Comment.Multiline */
.highlight .cp { color: #BC7A00 } /* Comment.Preproc */
.highlight .c1 { color: #408080; font-style: italic } /* Comment.Single */
.highlight .cs { color: #408080; font-style: italic } /* Comment.Special */
.highlight .gd { color: #A00000 } /* Generic.Deleted */
.highlight .ge { font-style: italic } /* Generic.Emph */
.highlight .gr { color: #FF0000 } /* Generic.Error */
.highlight .gh { color: #000080; font-weight: bold } /* Generic.Heading */
.highlight .gi { color: #00A000 } /* Generic.Inserted */
.highlight .go { color: #808080 } /* Generic.Output */
.highlight .gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.highlight .gs { font-weight: bold } /* Generic.Strong */
.highlight .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.highlight .gt { color: #0040D0 } /* Generic.Traceback */
.highlight .kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.highlight .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.highlight .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.highlight .kp { color: #008000 } /* Keyword.Pseudo */
.highlight .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.highlight .kt { color: #B00040 } /* Keyword.Type */
.highlight .m { color: #666666 } /* Literal.Number */
.highlight .s { color: #BA2121 } /* Literal.String */
.highlight .na { color: #7D9029 } /* Name.Attribute */
.highlight .nb { color: #008000 } /* Name.Builtin */
.highlight .nc { color: #0000FF; font-weight: bold } /* Name.Class */
.highlight .no { color: #880000 } /* Name.Constant */
.highlight .nd { color: #AA22FF } /* Name.Decorator */
.highlight .ni { color: #999999; font-weight: bold } /* Name.Entity */
.highlight .ne { color: #D2413A; font-weight: bold } /* Name.Exception */
.highlight .nf { color: #0000FF } /* Name.Function */
.highlight .nl { color: #A0A000 } /* Name.Label */
.highlight .nn { color: #0000FF; font-weight: bold } /* Name.Namespace */
.highlight .nt { color: #008000; font-weight: bold } /* Name.Tag */
.highlight .nv { color: #19177C } /* Name.Variable */
.highlight .ow { color: #AA22FF; font-weight: bold } /* Operator.Word */
.highlight .w { color: #bbbbbb } /* Text.Whitespace */
.highlight .mf { color: #666666 } /* Literal.Number.Float */
.highlight .mh { color: #666666 } /* Literal.Number.Hex */
.highlight .mi { color: #666666 } /* Literal.Number.Integer */
.highlight .mo { color: #666666 } /* Literal.Number.Oct */
.highlight .sb { color: #BA2121 } /* Literal.String.Backtick */
.highlight .sc { color: #BA2121 } /* Literal.String.Char */
.highlight .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.highlight .s2 { color: #BA2121 } /* Literal.String.Double */
.highlight .se { color: #BB6622; font-weight: bold } /* Literal.String.Escape */
.highlight .sh { color: #BA2121 } /* Literal.String.Heredoc */
.highlight .si { color: #BB6688; font-weight: bold } /* Literal.String.Interpol */
.highlight .sx { color: #008000 } /* Literal.String.Other */
.highlight .sr { color: #BB6688 } /* Literal.String.Regex */
.highlight .s1 { color: #BA2121 } /* Literal.String.Single */
.highlight .ss { color: #19177C } /* Literal.String.Symbol */
.highlight .bp { color: #008000 } /* Name.Builtin.Pseudo */
.highlight .vc { color: #19177C } /* Name.Variable.Class */
.highlight .vg { color: #19177C } /* Name.Variable.Global */
.highlight .vi { color: #19177C } /* Name.Variable.Instance */
.highlight .il { color: #666666 } /* Literal.Number.Integer.Long */
.highlight * { font-family: monospace; }
.highlight { font-size: 90%; }
.highlight { line-height: normal; }
.highlight .err { border: none !important }
.highlight > pre { word-wrap: break-word; white-space: pre-wrap; }
</style>
</head>
<body>
<div class="highlight"><pre>********************************************************************************
************                         Interfaz                       ************
********************************************************************************

Se explica con: Ciudad
G&#233;neros: Ciudad

********************************************************************************
************                       Operaciones                      ************
********************************************************************************

Crear(in m : Mapa) &#8594; res : Ciudad
Pre &#8801; {true}
Post &#8801; {res =obs Crear(m)} actualizar con la copia de mapa.
Complejidad: O(#estaciones(m) * |e&#8344;|)
Descripcion: Crea una nueva ciudad a partir de un mapa.
Aliasing: Se realiza una copia del mapa.

Entrar(in ts : conjRapidoString, in e : estacion, in/out c : Ciudad)
Pre &#8801; {e &#8712; estaciones(mapa(c)) &#8743; c =obs c&#8320;}
Post &#8801; {c =obs entrar(ts, e, c&#8320;)}
Complejidad: O(long(e) + S*R + N&#8348;&#8338;&#8348;&#8336;&#8343;)
Descripcion: Agrega un conjunto de caracteristicas nuevo a la ciudad, creando un nuevo robot.

Mover(in rur : nat, in e : estacion, in/out c : Ciudad)
Pre &#8801; {u &#8712; robots(c) &#8743; e &#8712; estaciones(c) &#8743;&#8343; 
conectadas?(estacion(u, c), e, mapa(c)) &#8743; c&#8320; =obs c}
Post &#8801; {c =obs mover(rur, e, c&#8320;)}
Complejidad: O(long(e) + long(estacion(u, c)) + log(#robotsEn(estacion(u,c), c)) + log(#robotsEn(e, c)))
Descripcion: Mueve a un robot de una estacion a otra.

Inspeccion(in e : estacion, in/out c : Ciudad)
Pre &#8801; {e &#8712; estaciones(c)}
Post &#8801; {c =obs inspecci&#243;n(e, c)}
Complejidad: O(long(e) + log(#robotsEn(e, c)))
Descripcion: Remueve al robot mas infractor en la estacion e de la ciudad.

ProximoRUR(in c : ciudad) &#8594; res : nat
Pre &#8801; {true}
Post &#8801; {res =obs ProximoRUR(c)}
Complejidad: O(1)
Descripcion: Devuelve el proximo rur disponible.

Mapa(in c : ciudad) &#8594; res : Mapa
Pre &#8801; {true}
Post &#8801; {res =obs Mapa(c)}
Complejidad: O(Copiar(c.mapa))
Descripcion: Devuelve el mapa de la ciudad.
Aliasing: res es una copia de mapa

Robots(in c : ciudad) &#8594; res : ItVectorPointer(robot)
Pre &#8801; {true}
Post &#8801; {alias(res =obs Iterador Unidireccional(Puntero(robot)))}
Complejidad: O(1)
Descripcion: Devuelve un iterador de los robots que hay en la ciudad.
Aliasing: res no es modificable.

Estacion(in c : ciudad, in u : nat) &#8594; res : estacion
Pre &#8801; {u &#8712; robots(c)}
Post &#8801; {res =obs estacion(u, c)}
Complejidad: O(1)
Descripcion: Devuelve la estacion donde esta el robot con rur u.

Tags(in c : ciudad, in u : nat) &#8594; res : itConj(string)
Pre &#8801; {u &#8712; robots(c)}
Post &#8801; {alias(esPermutacion?(SecuSuby(res), tags(u, c)) &#8743; vacia?(Anteriores(res)))}
Complejidad: O(1)
Descripcion: Devuelve un iterador a los tags del robot u.
Aliasing: res no es modificable.

#Infracciones(in c : ciudad, in u : nat) &#8594; res : nat
Pre &#8801; {u &#8712; robots(c)}
Post &#8801; {res =obs #infracciones(u, c)}
Complejidad: O(1)
Descripcion: Devuelve la cantidad de infracciones del robot con rur u.

********************************************************************************
************                     Representaci&#243;n                     ************
********************************************************************************

Ciudad se representa con city,
    donde city es: tupla(
                        robots           : VectorPointer(robot),
                        mapa             : Mapa,
                        robotsEnEstacion : DiccString(colaPrioridad(robot)))
    donde robot es: tupla(
                        rur                  : nat,
                        infracciones         : nat,
                        tags                 : Puntero(conjRapidoString),
                        estacion             : string,
                        infringe_restriccion : Vector(Bool),
                        mi_estacion          : itCola(robot)
    )

Pre &#8801; {true}
Post &#8801; {res =obs (r1 &lt; r2)}
Complejidad: O(1)
Descripci&#243;n: funcion de comparaci&#243;n de robots
&#8729; &lt; &#8729; (in r1 : robot, r2 : robot) &#8594; res : bool
    if r1.infracciones &lt; r2.infracciones then
        res &#8592; true
    else
        if r1.infracciones == r2.infracciones then
            res &#8592; r1.rur &lt; r2.rur
        else
            res &#8592; false
        end if
    end if
end function

Escribimos el rep de ciudad informalmente:

&#8729; Las claves del diccionario e.robotsEnEstacion todas pertenecen a las estaciones
definidas en e.mapa.
&#8729; Todos los robots pertenecientes a las colas de los significados de e.robotsEnEstacion
tienen la clausula estac&#237;on puesta al sigificado de la cola a la que pertenecen.
&#8729; Los elementos de e.robots que no sean NULL cumplen que
    &#8729; El rur es igual a su indice en e.robots.
    &#8729; El robot pertenece a la cola de prioridad en la entrada estacion de
    e.robotsEnEstacion (obviamente, la entrada debe estar tambi&#233;n definida).
    &#8729; mi_estacion se corresponde con la posici&#243;n del robot en la cola de prioridad
    asociada a la estaci&#243;n en la que se encuentra.
    &#8729; infringe_restriccion se corresponde con los caminos que hay en el mapa, y
    aparte se corresponde con si el robot verifica o no la restricci&#243;n entre las
    sendas.
    &#8729; Los elementos en tags tienen una longitud menor o igual a 64.

Abs: ^(city) c &#8594; Ciudad                                                 {Rep(c)}
(&#8704;e : ^(city)) Abs(e) =obs c /
    convertir(e.robots) =obs robots(c) &#8743;
    long(e.robots) =obs ProximoRUR(c) &#8743;
    e.mapa =obs mapa(c) &#8743;
    (&#8704;u : rur)
        (u &lt; Longitud(e.robots) &#8743;&#8343; e.robots[u] != NULL) &#10233;&#8343;
            ((e.robots[u].estacion =obs estacion(u, c)) &#8743;
            (e.robots[u].tags =obs tags(u, c)) &#8743;
            (e.robots[u].infracciones =obs #infracciones(u, c)))

convertir: secu(puntero(&#945;)) &#8594; conj(&#945;)
convertir(xs) &#8801;
    if vacia?(xs) then &#981;
    else
        if prim(xs) =obs NULL then convertir(fin(xs))
        else Ag(prim(xs), convertir(fin(xs))) fi
    fi

********************************************************************************
************                      Algoritmos                        ************
********************************************************************************

iCrear(in m : Mapa) &#8594; res : city
    var robots_en_estacion: DiccString(ColaPrioridad(robot)) &#8592; Crear()
    var it: itConj(string) &#8592; Estaciones(m)

    while HaySiguiente(it) do
        Definir(robots_en_estacion, Siguiente(it), Crear())
        Avanzar(it)
    end while

    Definir(robots_en_estacion, *it, Crear())

    res &#8592; &#10216;robots: Vacia(), mapa: Copiar(m), robotsEnEstacion: robots_en_estacion&#10217;
end function

Recorrer todas las estaciones en el mapa es O(E). Definir cada entrada en
robots_en_estacion es O(|e&#8344;|), siendo e&#8344; el nombre de estacion mas largo, y hay
que hacerlo E veces. Por esto, la complejidad es O(|e&#8344;| * E).

iEntrar(in ts : conjRapidoString, in e : estacion, in/out c : city)
    var rob : robot &#8592; &#10216;
        tags: &amp;ts,
        infracciones: 0,
        rur: ProximoRUR(city),
        infringe_restriccion: Vacia(),
        estacion: e,
        mi_estacion: Encolar(obtener(robotsEnEstacion, e), rob)&#10217;

    var it : ItVectorPointer(Restriccion) &#8592; Sendas(c.mapa)

    while HayMas?(it) do
        AgregarAtras(rob.infringe_restriccion, &#172;Verifica?(ts, *Actual(it)))
        Avanzar(it)
    end while

    AgregarAtras(c.robots, &amp;rob)
end function

La operacion obtener(robotsEnEstacion, e) tiene complejidad O(|e|). La operacion
Encolar de cola de prioridad es O(Log de la cantidad de elementos de la cola).
Como se evaluan todas las sendas para saber si un robot infringe o no, el recorrido
lineal del iterador es O(S), siendo S la cantidad de sendas que hay en el mapa.
Evaluar si un robot infringe o no cada senda (Verifica?) es O(R). Finalmente,
agregar un robot a robots de la ciudad es O(N) en el peor caso, siendo N la cantidad
de robots en la ciudad, como esta explicado en agregar atras de vector. Este O(N)
por algebra de ordenes acota superiormente al costo logaritmico de encolar.
Luego, la complejidad queda en |e| + S*R + N&#8348;&#8338;&#8348;&#8336;&#8343;.

iMover(in rur : nat, in e : estacion, in/out c : city)
    var rob : puntero(robot) &#8592; c.robots[rur]

    Borrar(Obtener(c.robotsEnEstacion, rob&#8594;estacion), rob&#8594;mi_estacion)

    var infringe : nat &#8592; rob&#8594;infracciones
    var id_senda : nat &#8592; idSenda(c.mapa, rob&#8594;estacion, e)

    if rob&#8594;infringe_restriccion[id_senda] then
        infringe++
    end if

    rob&#8594;infracciones &#8592; infringe
    rob&#8594;estacion &#8592; e
    rob&#8594;mi_estacion &#8592; Encolar(obtener(c.robotsEnEstacion,  e), *rob)
end function

La complejidad de Obtener es O(|e1|), siendo e1 rob&#8594;estacion.
Borrar de la cola de prioridad teniendo el iterador al elemento es O(Log(#cola)),
siendo #cola la cantidad de elementos de la cola. Todo el calculo de si infringe
o no es O(1) porque ya esta precalculado. Luego, insertarlo en otra cola es O(|e|)
para encontrarla en el diccionario y O(Log(#cola)) para insertarlo. Esto da como
resultado O(|e1| + |e| + Log(#cola1) + Log(#cola2)).

iInspeccion(in e : estacion, in/out c : city)
    var cola : colaPrioridad(robot) &#8592; Obtener(c.robotsEnEstacion, e)

    if tama&#241;o(cola) &gt; 0 then
        var rob : robot &#8592; Desencolar(cola)
        c.robots[rob.rur] &#8592; NULL
    end if
end function

iProximoRUR(in c : city) &#8594; res : nat
    res &#8592; Longitud(c.robots)
end function

iMapa(in c : city) &#8594; res : Mapa
    res &#8592; Copiar(c.mapa)
end function

iRobots(in c : city) &#8594; res : ItVectorPointer(robot)
    res &#8592; CrearIt(c.robots)
end function

iEstacion(in c : city, in u : nat) &#8594; res : estacion
    res &#8592; (c.robots[u])&#8594;estacion
end function

iTags(in c : city, in u : nat) &#8594; res : itConj(string)
    res &#8592; CrearIt((c.robots[u])&#8594;tags)
end function

i#Infracciones(in c : city, in u : nat) &#8594; res : nat
    res &#8592; (c.robots[u])&#8594;infracciones
end function
</pre></div>

<script>
// Indent wrapped lines in order to keep them out of the line-numbering column.

// One of these methods should work for a given browser; though this means
// possibly running the hangingIndent routine 3 times, it also ensures we successfully
// wrap all code blocks, all the time, on all tested browsers.
document.addEventListener('DOMContentLoaded', hangingIndentAllCodeBlocks, false);
window.addEventListener('load', hangingIndentAllCodeBlocks, false);
hangingIndentAllCodeBlocks();

// Apply hanging indent CSS to wrapped lines in each div.highlight code block
function hangingIndentAllCodeBlocks() {
    var blocks = document.getElementsByClassName('highlight');
    for (var i = 0; i < blocks.length; i++) {
        hangingIndentCodeBlock(blocks[i]);
    }
}

// Apply hanging indent CSS to wrapped lines in given block
function hangingIndentCodeBlock(block) {
    var lineNums = block.querySelectorAll('.lineno');
    if (lineNums.length == 0) {
        return;
    }

    // Calculate actual width of a character in the line numbers column
    var first = lineNums[0];
    var text = first.innerText || first.textContent;
    var charWidth = first.offsetWidth / text.length;

    // Adjustment width is width of line number column plus 1 more character-width
    // for the trailing space that comes after the span.lineno element
    var adjustWidth = charWidth * (text.length + 1);

    // Indent the entire block by adjustWidth ...
    block.firstChild.style.marginLeft = adjustWidth + 'px';

    // ... and correspondingly de-indent just the starting line-number <span> of
    // each line-of-code, resulting in only wrapped lines of code being indented
    // past the column of line numbers
    for (var i = 0; i < lineNums.length; i++) {
        lineNums[i].style.marginLeft = -adjustWidth + 'px';
    }
}
</script>
</body>
</html>